
# delete leaf nodes - match to parent tree


#p â† 0â€¿0â€¿1â€¿1â€¿1â€¿5â€¿5â€¿6â€¿6
p â† 0â€¿0â€¿1â€¿1â€¿1â€¿5â€¿5â€¿6â€¿6â€¿0â€¿9â€¿9â€¿10
q â† 0â€¿0â€¿2â€¿2

_Fix â† {ğ”½âˆ˜âŠ¢âŸâ‰¢âŸœğ”½_ğ•£âˆ˜âŠ¢âŸâ‰¢âŸœğ”½ğ•©}
Depth  â† { pâ†ğ•© â‹„ dâ†pâ‰ (â†•â‰ p) â‹„ { zâ†ğ•©âŠp â‹„ d+â†©zâ‰ ğ•© â‹„ z } _Fix p â‹„ d } 
Delete â† { (/ğ•¨)(âŠ¢-â‹)(Â¬ğ•¨)/ğ•© }
Leaf â† { Â¬(â†•â‰ ğ•©)â·ğ•© }

# example:
# â—‹
# â”œâ”€â”¬â”€â”
# â—‹ â—‹ â—‹

type â† { noneâ‡0 â‹„ nodeâ‡1 â‹„ horzâ‡2 â‹„ midâ‡3 â‹„ startâ‡4 â‹„ endâ‡5 â‹„ vertâ‡6 }

Draw â† {
  r â† {ğ•©âŠp} _fix p â‹„ d â† Depth ğ•©                      # r: roots. d: depth

  {
    â€¢Show "-"
    mâ† ğ•©=r                                            # mask for current root
    parâ†@ â‹„ hâ†@ â‹„ nâ†@

    parâ†©{ (1+ğ•©/m/p)âŒ¾(ğ•©âŠ¸/) ğ•© }Ë˜mâŠ¸/Ë˜d=âŒœËœâ†•âŒˆÂ´d+1          # depth matrix to parent vector offset by 1 since null values are 0
    parâ†©âˆ¾Ë˜(â†•â‰ par) {Â«âŸğ•¨ ğ•©} Ë˜par                        # shift diagonal zeros to vertical line


    eâ†parÃ—>âŸœÂ«Ë˜par
    sâ†parÃ—>âŸœÂ»Ë˜par
    sâ†©sÃ—âˆŠË˜s          # mark first starts of parent
    eâ†©eÃ—{âŒ½âˆŠâŒ½ğ•©}Ë˜e     # mark first endings of parent

    nâ†©(<2)â€¿(<2)/par
    nâ†©0<{Â«ğ•©âˆ§2|â†•â‰ ğ•©}Ë˜0Â¨âŒ¾((2|â†•â‰ n)âŠ¸/) n               # nodes by finding every second level then every second item within the level

    hâ†© parâŒˆ+`Ë˜s-e  # extend parents to horizontal 
    hâ†©(<2)â€¿(<2)/h # create pad spacing
    hâ†©hâˆ§Â¬{ğ•©>Â«ğ•©}Ë˜h # remove overflow hendings
    hâ†©Â«0Â¨âŒ¾((2|â†•â‰ h)âŠ¸/) h # bars on every second level and shift up
    hâ†©type.horzÃ—0âŠ¸< h # set base type for bars
    hâ†©hâŒˆ(type.startÃ—>âŸœÂ»Ë˜h)+(type.endÃ—>âŸœÂ«Ë˜h)           # find start and end bars
    hâ†©hâŒˆtype.midÃ—Â«n                                   # find mid bars that have children
    hâ†©hâŒŠtype.vert                                     # clamp to vertical bar if both start and end

    â€¢Show nâŒˆh

    #â€¢Show â‰¢h
    #â€¢Show 1â€¿1/[(â‰ h)â¥Š1,(â‰ h)â¥Š0]
    #extend until
    #parâ†©(<2)â€¿(<2)/par                                 # pad offsets for render characters

    #nâ†0<{Â«ğ•©âˆ§2|â†•â‰ ğ•©}Ë˜0Â¨âŒ¾((2|â†•â‰ par)âŠ¸/) par               # nodes by finding every second level then every second item within the level
    #â€¢Show par

    #hâ†parâˆ§Â¬{ğ•©>Â«ğ•©}Ë˜par # remove overflow hendings
    #hâ†©type.horzÃ—0âŠ¸< Â«0Â¨âŒ¾((2|â†•â‰ h)âŠ¸/) h                 # nodes by finding every second level then every second item within the level
    #â€¢Show 0<s
    #hâ†©hâŒˆ(type.start)+(type.endÃ—>âŸœÂ«Ë˜h)           # find start and end bars
    #â€¢Show h
    #â€¢Show {ğ•©>Â«ğ•©}Ë˜h
    #â€¢Show {ğ•©>Â»ğ•©}Ë˜h
    #â€¢Show h
    #â€¢Show s
    #â€¢Show +`s-e
    #â€¢Show hâ†{(0<âŒˆ`ğ•©)âˆ§âŒ½0<âŒˆ`âŒ½ğ•©}Ë˜par
    #â€¢Show hâ†(+`Ë˜par-e)âˆ§Ë˜{ (0<+`ğ•©)âˆ§âŒ½0<+`âŒ½ğ•© }Ë˜par               # extended parents across horizontal

    #hâ†©{0Â¨âŒ¾((>âŸœÂ«ğ•©)âŠ¸/) ğ•©}Ë˜h                             # remove overflow endings
    #hâ†©hâŒˆ(type.startÃ—>âŸœÂ»Ë˜h)+(type.endÃ—>âŸœÂ«Ë˜h)           # find start and end bars
    #hâ†©hâŒˆtype.midÃ—Â«n                                   # find mid bars that have children
    #hâ†©hâŒŠtype.vert                                     # clamp to vertical bar if both start and end

    ##â€¢Show hâŒˆn
    {â€¢Out âŠ¢â—¶" â—‹â”€â”¬â”œâ”â”‚"Â¨ğ•©}Ë˜hâŒˆn
  } Â¨â· r
}

Draw p
