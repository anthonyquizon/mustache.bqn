# Reference: http://mustache.github.io/mustache.5.html
#            https://juuso.dev/blogPosts/barbell/barbell.html
#            https://www.youtube.com/watch?v=5I4YPkVU7mY

# types
âŸ¨ none, opn_bkt, cls_bkt, hash, slash, str, bang,     # characters
  opn_dm, cls_dm,                   # markers
  tag, opn, cls, key                                  # tags
âŸ© â† â†•13

labels â‡ âˆ¾âŸ¨
  "f......",
  "..",
  "tock"
âŸ©

âŸ¨DrawâŸ©â†â€¢Import "tree.bqn"
#p: previous value
_fix â† { Fnâ†ğ”½ â‹„ pâ†@ â‹„ {râ†p Fn ğ•© â‹„ pâ†©ğ•© â‹„ r} â€¢_while_ { ğ•©â‰¢p } ğ•© â‹„ p }

Delete â† { (/ğ•¨)(âŠ¢-â‹)(Â¬ğ•¨)/ğ•© }
Parent â‡ { gâ†âŠ”ğ•© â‹„ (â†•â‰ ğ•©) {aâ€¿wâ†ğ•¨ â‹„ (âŠâŸœa 1-Ëœaâ‹w)âŒ¾(wâŠ¸âŠ) ğ•© }Â´ (1â†“(Â»g){ğ•¨â€¿ğ•©}Â¨g) }
Depth  â‡ { pâ†ğ•© â‹„ dâ†pâ‰ (â†•â‰ p) â‹„ { zâ†ğ•©âŠp â‹„ d+â†©zâ‰ ğ•© â‹„ z } _Fix p â‹„ d } 
PathMat â† { pâ†ğ•¨ â‹„ ppâ†ğ•© â‹„ {qâ†ğ•©âŠp â‹„ pp â†©ppâˆ¾Ë˜q â‹„ q} _Fix pp â‹„ Â¯1â†“Ë˜pp }

# parse namespaces and to parent tree
ParseNs â‡ {
    ğ•Š ğ•© :  
       âŸ¨s,d,tâŸ© â† 0 ğ•Š ğ•© 
       mâ†0âŠ¸=âˆ˜â‰ Â¨s â‹„ pâ†(Parent d) 
       # remove empty strings
       râ†(â†•(â‰ s)-(â‰ /m))âŒ¾((Â¬m)âŠ¸/) (â‰ s)â¥ŠÂ¯1 â‹„ nâ† sâ†©(Â¬m)/s
       # remove duplicate strings
       râ†©(âŠn)âŒ¾((0â‰¤r)âŠ¸/) r
       nâ†© â·n 

       {ptrâ‡[p,t,r], nâ‡n};
  d ğ•Š ns : 6â‰¡â€¢Type ns ? 
    childrenâ†âˆ¾Â¨Â´{ âŸ¨âŸ¨ğ•©âŸ©, (d+1), âŸ¨'k'âŸ©âŸ© âˆ¾Â¨ (d+2) ParseNs (ns â€¢ns.Get ğ•©) } Â¨â€¢ns.Keys ns
    âŸ¨âŸ¨""âŸ©, âŸ¨dâŸ©, âŸ¨'o'âŸ©âŸ© âˆ¾Â¨ children;
  d ğ•Š ğ•© : 0â‰¡â€¢Type ğ•© ?
    { ğ•Š s : âˆ§Â´2âŠ¸â‰¡âˆ˜â€¢TypeÂ¨s ? âŸ¨âŸ¨sâŸ©, âŸ¨dâŸ©, âŸ¨'v'âŸ©âŸ© ; # parse string
      ğ•Š ğ•© : âˆ¾Â¨Â´{ (d) ParseNs ğ•©}Â¨ğ•© 
    } ğ•©;
  ğ•¨ ğ•Š ğ•© : 1â‰¡â€¢Type ğ•© ? ğ•¨ ğ•Š â€¢Fmt ğ•©
}


Parse â‡ {
  châ†ğ•© â‹„ tâ†@ â‹„ râ†@ â‹„ nâ†@ â‹„ pâ†@
  { tâ†© âˆ¨Â´âŸ¨opn_bkt,cls_bkt,hash,slashâŸ©Ã—châŠ¸=Â¨"{}#/" }                                    # tokenize character types
  { mâ†t=opn_bkt â‹„ qâ†opn_dmÃ—>âŸœÂ«m â‹„ zâ†(Â¬m)âˆ¨0<q â‹„ tâ†©z/tâŒˆq â‹„ châ†©z/ch }                     # find double opn brackets then collapse and mark into a delimeter
  { mâ†t=cls_bkt â‹„ qâ†cls_dmÃ—>âŸœÂ«m â‹„ zâ†(Â¬m)âˆ¨0<q â‹„ tâ†©z/tâŒˆq â‹„ châ†©z/ch }                     # find double close brackets then collapse and mark into a delimeter
  { mâ†câˆ¨+`(t=opn_dm)-(câ†t=cls_dm) â‹„ tâ†©tÃ—m }                                            # demote any characters outside delims as none
  { mâ†t=none â‹„ sâ†>âŸœÂ» m â‹„ eâ†>âŸœÂ« m                                                       # find fragments and tags. ch no longer needed
    zâ†(0<t)âˆ¨(0<s) â‹„ tâ†© z/tâŒˆsÃ—str â‹„ nâ†© âŠâŸœchÂ¨1â†“âŠ”mâˆ§+`s â‹„ râ†© (â†•â‰ n)âŒ¾((t=str)âŠ¸/) (â‰ t)â¥ŠÂ¯1 }   # collapse all zeros to frags and tag names
  { oâ†t=opn_dm â‹„ câ†t=cls_dm â‹„ zâ†Â¬c â‹„ tâ†©z/tâŒˆoÃ—tag â‹„ râ†©z/r }                             # find tags - delete open and close and lead with tag flag
  { mâ†(t=tag)âˆ§(Â«t=hash)âˆ§(Â«Â«t=str) â‹„ zâ†Â¬âˆ¨âŸœÂ»m â‹„ tâ†©z/tâŒˆÂ»Â»mÃ—opn â‹„ râ†©z/r }                  # mark opn tags - consume {# and set str as id (Â»Â»)
  { mâ†(t=tag)âˆ§(Â«t=slash)âˆ§(Â«Â«t=str) â‹„ zâ†Â¬âˆ¨âŸœÂ»m â‹„ tâ†©z/tâŒˆÂ»Â»mÃ—cls â‹„ râ†©z/r }                 # mark cls tags - consume {/ and set str as id (Â»Â»)
  { mâ†(t=tag)âˆ§(Â«t=str) â‹„ zâ†Â¬m â‹„ tâ†©z/tâŒˆ(Â»m)Ã—key â‹„ râ†©z/r }                               # mark cls tags - consume { and set str as id (Â»)
  { oâ†t=opn â‹„ câ†t=cls â‹„ pâ†©Parent dâ†Â»+`o-c â‹„ "unbalanced template tags"!0â‰¡Â¯1âŠ‘d }                                            # create parent vector
  { mâ†(t=opn) â‹„ tâ†©tâŒˆmÃ—key }                                                            # mark opn tags as keys
  { mâ†(t=cls) â‹„ zâ†Â¬m â‹„ pâ†©m Delete p â‹„ tâ†©z/t â‹„ râ†© z/r-+`Â¬z â‹„ nâ†© z/n }                   # Delete cls tags with unused names and shift r
  { râ†©(âŠn)âŒ¾((0â‰¤r)âŠ¸/) r â‹„ nâ†© â·n }                                                       # remove duplicate strings
  { tâ†© âŠ¢â—¶labelsÂ¨t  } # convert number types to character


  { ptrâ‡ [p, t, r] â‹„ nâ‡n }
}


Compile â‡ {
 ğ•¨ ğ•Š ğ•© : {6â‰¡â€¢Type ğ•©}â—¶0â€¿{Â¬ğ•© â€¢ns.Has "ptr"} ğ•© ? ğ•¨ ğ•Š (ParseNs ğ•©);
 ğ•¨ ğ•Š ğ•© : {6â‰¡â€¢Type ğ•©}â—¶1â€¿{Â¬ğ•© â€¢ns.Has "ptr"} ğ•¨ ? (Parse ğ•¨) ğ•Š ğ•©;
 ğ•¨ ğ•Š ğ•© : 
  âŸ¨[tp,tt,tr]â‡ptr,tnâ‡nâŸ©â†ğ•¨ â‹„ âŸ¨[dp,dt,dr]â‡ptr,dnâ‡nâŸ©â†ğ•©
  dmapâ†@ # map of data key indices to template key indices

  # find matching key paths
  { KP â† { p ğ•Š t: ppâ†/t='k' â‹„ { qâ†ğ•©âŠp â‹„ ppâ†©ppâˆ¾Ë˜q â‹„ q } _Fix pp â‹„ Â¯1â†“Ë˜pp } # key paths. Drop self reference root
    trpâ†âŠâŸœtrÂ¨â·Â¨<Ë˜tp KP tt â‹„ dkpâ† {ğ•©/Ëœ'k'=ğ•©âŠdt}Â¨<Ë˜dp KP dt # trp: template reference path - key paths as references. dkp: key path of data with non key parents removed
    mâ†dt='k'â‹„ mapâ†Â¯1Â¨âŒ¾((Â¬m)âŠ¸/) { tnâŠğ•©âŠdn }âŒ¾(mâŠ¸/) dr # map of data keys to template keys (assumes keys point to unique names)
    dmapâ†©((Â¯1âˆ¾Ëœ/tt='k')âŠËœtrpâŠâŠâŸœmapÂ¨dkp)âŒ¾(mâŠ¸/) Â¯1Â¨dr # data mapping of keys to template reference map indices 
  } 

  # remove unneeded data (Helps with debuging)
  { zâ†(dt='k')âˆ§(dmap=Â¯1) â‹„ { zâ†©zâˆ¨(ğ•©âŠz) â‹„ ğ•©âŠdp} _fix dp          # prune key strings that don't exist path mapping
    dpâ†©z Delete dp â‹„ dtâ†©(Â¬z)/dt â‹„ drâ†©(Â¬z)/dr â‹„ dmapâ†©(Â¬z)/dmap # mark unused data variables and remove orphanded children
  }                           

  { ppâ†vâ†dmapâŠËœdpâŠËœ/dt='v' â‹„ { ppâ†©ppâˆ¾Ë˜sâ†ğ•©âŠtp â‹„ s } _fix pp â‹„ ppâ†©Â¯1â†“Ë˜pp # pp: parent path. Drop root self reference.

    â€¢Show pp
    #â€¢Show (/dt='v')âŠdpâŠdmapâŠtrâŠtn
    #â€¢Show (0âŠË˜pp)âŠtn
  }

}

Compile0 â‡ {
 ğ•¨ ğ•Š ğ•© : {6â‰¡â€¢Type ğ•©}â—¶0â€¿{Â¬ğ•© â€¢ns.Has "ptr"} ğ•© ? ğ•¨ ğ•Š (ParseNs ğ•©);
 ğ•¨ ğ•Š ğ•© : {6â‰¡â€¢Type ğ•©}â—¶1â€¿{Â¬ğ•© â€¢ns.Has "ptr"} ğ•¨ ? (Parse ğ•¨) ğ•Š ğ•©;
 ğ•¨ ğ•Š ğ•© : 
  âŸ¨[tp,tt,tr]â‡ptr,tnâ‡nâŸ©â†ğ•¨ â‹„ âŸ¨[dp,dt,dr]â‡ptr,dnâ‡nâŸ©â†ğ•©
  outâ†@â‹„ knâ†((tt='k')/tr)âŠtn â‹„ dmâ†@ â‹„ tkâ†@ â‹„ dkâ†@  # kn: key strings. dm: lowest data keys that map to template key paths
  Dbn â†{{â€¢Show (ğ•©âŠtr)âŠtn}Â¨ğ•© } #debug names

  # create find matching reference paths from keys. 
  # ie foo->bar->baz in data matches with foo->bar->baz in template rather than foo->bar->quux
  { kâ†(((tt='k')/tr)âŠtn) â‹„ tkâ†©Â¯1Â¨tr â‹„ tkâ†©(knâŠk)âŒ¾((tt='k')âŠ¸/) tk }
  { kâ†(((dt='k')/dr)âŠdn) â‹„ dkâ†©Â¯1Â¨dr â‹„ dkâ†©(knâŠk)âŒ¾((dt='k')âŠ¸/) dk }                     # remap data key reference names to shared reference names to have common indices

  {
    dp
  }


  # match data key paths to template key paths
  { 
      â€¢Show tp PathMat /(tt='k')
      â€¢Show dp PathMat /(dt='k')

    trpâ† â€¢Show âŠâŸœtkË˜tp PathMat /(tt='k') â‹„ nâ†1âŠ‘â‰¢trp                                         # trp: template reference paths
    drpâ† â€¢Show âŠâŸœdkË˜{ mâ†ğ•©/Ëœ'k'=ğ•©âŠdt â‹„ nâ†‘mâˆ¾nâ¥ŠâŠ‘âŒ½m }Ë˜ dp PathMat /(dt='k')                     # drp: data reference paths



    ksâ†trpâŠ¸âŠË˜drp â‹„ kâ†/tt='k' â‹„ mâ†ksâ‰ â‰ k â‹„ ksâ†©(âŠâŸœk)âŒ¾(mâŠ¸/) ks â‹„ ksâ†©Â¯1Â¨âŒ¾((Â¬m)âŠ¸/) ks       # convert keyspace to normal index space with Â¯1 as non index
    dmâ†©ksâŒ¾((dt='k')âŠ¸/) Â¯1Â¨dt 
  }                                                        # mappings from data keys to template keys Â¯1 if not a key

  { zâ†(dt='k')âˆ§(dm=Â¯1) â‹„ { zâ†©zâˆ¨(ğ•©âŠz) â‹„ ğ•©âŠdp} _fix dp                                  # prune key strings that don't exist path matrix ie don't exist as a tempalate variable. Helps with debuhing
    dpâ†©z Delete dp â‹„ dtâ†©(Â¬z)/dt â‹„ drâ†©(Â¬z)/dr â‹„ dmâ†©(Â¬z)/dm }                           # mark unused data variables and remove orphanded children

  {
    #ppâ†vâ†dmâŠËœdpâŠËœ/dt='v' â‹„ { ppâ†©ppâˆ¾Ë˜sâ†ğ•©âŠtp â‹„ s } _fix pp â‹„ ppâ†©1â†“<Ë˜â‰Â¯1â†“Ë˜pp # pp: parent path. Drop root self reference.
    ppâ†vâ†dmâŠËœdpâŠËœ/dt='v' â‹„ { ppâ†©ppâˆ¾Ë˜sâ†ğ•©âŠtp â‹„ s } _fix pp â‹„ ppâ†©Â¯1â†“Ë˜pp # pp: parent path. Drop root self reference.

    #â€¢Show pp
    #mâ†{ mâ†âŠ+`Â»âŠ¸â‰ ğ•© }Â¨pp
    ##râ†{ â‰ Â¨âŠ”ğ•© }Â¨m # repeats 
    #sâ† m { sâ†{/ğ•©=tp}Â¨âŠ‘Â¨ğ•¨âŠ”ğ•© }Â¨pp  # siblings list of each level
    #â€¢Show m 
    #â€¢Show Â¨s
    #â€¢Show {

      #(ğ•©âŠtr)âŠtn

    #}Â¨s
    #â€¢Show s
    #â€¢Show r
    #â€¢Show (1â†“s) {
      #â€¢Show ğ•¨â€¿ğ•©
    #} Â¨(Â¯1â†“mâŠ”Â¨pp)

    #uâ†{
      #sâ€¿pâ†ğ•©
      ##should not be first
    #}Â¨1â†“sâ‹ˆÂ¨(Â»p)
    #uâ† p { ğ•¨=ğ•© }Â¨s # replacement mask for under operation
    #sâ†©r { ğ•¨{ ğ•¨â¥ŠâŸ¨ğ•©âŸ© }Â¨ğ•© }Â¨ s # flatten siblings

    #â€¢Show s
    #â€¢Show p
    #â€¢Show u
    #â€¢Show m
    #â€¢Show p
    #â€¢Show u
    #â€¢Show s


    #â€¢Show m
    #â€¢Show "--"
    #â€¢Show "--"

    #â€¢Show m
    #â€¢Show s
    #{
      #aâ€¿bâ†ğ•©
      #â€¢Show bmâ†âŠ+`Â»âŠ¸â‰ b



    #} Â¨Â¯1â†“ppâ‹ˆÂ¨Â«pp
    #{} Â¨ pp


    #{  


    #}Â¨s

    
    #{
      #â€¢Show "2"
      #â€¢Show ğ•©
      #â€¢Show mâ†âŠ+`Â»âŠ¸â‰ ğ•© 
      #â€¢Show sâ†{/ğ•©=tp}Â¨âŠ‘Â¨mâŠ”ğ•© 

      
    #} 2âŠ‘<Ë˜â‰pp 

    #wâ†v
    #{
      #â€¢Show "-"
      #mâ†âŠ+`Â»âŠ¸â‰ ğ•© 
      #qâ†mâŠ”a 
      #pâ†âŠ‘Â¨mâŠ”ğ•© 
      #sâ†{/ğ•©=tp}Â¨p

      #{
        #â€¢Show [a,b,c]â†ğ•©
        #Â¨b
      #} Â¨<Ë˜â‰[s,mâŠ”a,mâŠ”w] 

      ##(âŠ‘Â¨mâŠ”b) {
        ##pâ†ğ•¨
        ##â€¢Show a
        ###â€¢Show âŒ¾(ğ•¨=ğ•©)
      ##}Â¨s

      

      #wâ†©ğ•©

      ##â€¢Show s
      ##â€¢Show ğ•©
      ##â€¢Show q { 
        
        ##â€¢Show ğ•¨â€¿ğ•©
        ###ğ•©Â¨âŒ¾((ğ•¨â·s)âŠ¸/) s 
        ##ğ•©
      ##}Â¨s

      #ğ•©
      ##sâ†{/ğ•©=tp}Â¨ğ•©
      ##ğ•¨ { 
        ##sâ†/ğ•©=tp
      ##}Â¨ğ•©
    #}Â¨1â†“<Ë˜â‰pp
    

    #{
      #â€¢Show "-"
      #â€¢Show ğ•©
        ##sâ†{/ğ•©=tp}Â¨ğ•©âŠtp

      #â€¢Show { 
        #{â€¢Show ğ•©âŠtp}Â¨ğ•© 
        #ğ•©
      #}âŒ¾(mâŠ¸âŠ”) ğ•©

    #}Â¨<Ë˜â‰pp

    ! 0
    #sâ†{
      #â€¢Show "-"
      #mâ†âŠ+`Â»âŠ¸â‰ ğ•©
      #qâ†âŠ‘Â¨mâŠ”ğ•©
      #zâ† âˆ¾Â¨mâŠ”sâ†{/ğ•©=tp}Â¨ğ•©âŠtp

      #â€¢Show z
      #â€¢Show m
      #â€¢Show a

      #â€¢Show aâ†©q {
        #sâ€¿aâ†ğ•© â‹„ âˆ¾(a)âŒ¾((ğ•¨â·s)âŠ¸/) s
      #} Â¨z{ğ•¨â€¿ğ•©}Â¨mâŠ”a
    #}Â¨2â†‘<Ë˜â‰pp







    #aâ†@
    
        #sâ†ğ•© â‹„ pâ†/tp=ğ•¨âŠtp â‹„râ†ğ•¨â·p â‹„ nâ†(Â¬âˆ¨Â´ğ•¨â·âˆ¾ğ•©) # p: next parent list. r: current root position that will replace with current level references. n: number to children and number of times to duplicate current template level if the parent itself exist in parent list
    #v0â†{
      #â€¢Show "1"
      #pâ†ğ•©âŠtp
      #â€¢Show aâ†© {/ğ•©=tp}Â¨p
      #p
    #} v

    #v1â†{
      #â€¢Show "2"
      #â€¢Show pâ†ğ•©âŠtp
      #â€¢Show mâ†âŠ+`Â»âŠ¸â‰ p
      #â€¢Show sâ†{/ğ•©=tp}Â¨p
      #â€¢Show râ†ğ•©=s

      #aâ†©<Ë˜{ sâ€¿râ€¿aâ†ğ•© â‹„ âˆ¾aÂ¨âŒ¾(râŠ¸/) s }Ë˜â‰[s,r,a]
      #aâ†© âˆ¾Â¨mâŠ”a
      ##â€¢Show âˆ¾mâŠ”ğ•©
      #p
    #} v0

    #v2â†{
      #â€¢Show "2"
      #â€¢Show pâ†ğ•©âŠtp
      #â€¢Show mâ†âŠ+`Â»âŠ¸â‰ p
      #â€¢Show sâ†{/ğ•©=tp}Â¨p
      #â€¢Show râ†ğ•©=s

      #aâ†©<Ë˜{ sâ€¿râ€¿aâ†ğ•© â‹„ âˆ¾aÂ¨âŒ¾(râŠ¸/) s }Ë˜â‰[s,r,a]
      #â€¢Show aâ†© âˆ¾Â¨mâŠ”a
      #p
    #} v1
    #â€¢Show ppâ†©(â†•â‰ pp)âˆ¾Ë˜pp
    #â€¢Show p
    #a0â†âŸ¨âŸ©

    ## create parent mask
    #â€¢Show pp
    #â€¢Show (â‰Â«Ë˜pp) {

    #â€¢Show "--"
    #â€¢Show ğ•¨â€¿ğ•© 

    #} Ë˜ â‰pp

    #gpâ† { âˆ¾â·Â¨(1-Ëœ+`Â»âŠ¸â‰ ğ•©)âŠ”ğ•© }Â¨1â†“<Ë˜â‰pp
    
    #aâ†(1-Ëœ+`Â»âŠ¸â‰ p0)âŠ”p0
    #{
      #â€¢Show "-"
      #mâ†(1-Ëœ+`Â»âŠ¸â‰ ğ•©)
      #â€¢Show m
      #â€¢Show a
      #â€¢Show aâ†© mâŠ”a
      ##â€¢Show ğ•©

    #}Â¨gp
    #â€¢Show {
      #â€¢Show "--"
      ##â€¢Show ğ•©
      ##â€¢Show â·ğ•©
      ##â€¢Show gâ†(1-Ëœ+`Â»âŠ¸â‰ ğ•©)
      ##â€¢Show pâ†â·Â¨gâŠ”acc
      #â€¢Show ğ•¨â€¿ğ•©
      #â€¢Show ğ•©
      #â€¢Show âŠ‘
      #â€¢Show (1-Ëœ+`Â»âŠ¸â‰ ğ•©)âŠ”ğ•¨
      ##â€¢Show (â·Â¨1-Ëœ+`Â»âŠ¸â‰ ğ•©)âŠ”ğ•¨
      ##a0â†©a0âˆ¾âŸ¨(1-Ëœ+`Â»âŠ¸â‰ ğ•©)âŠ”accâŸ©
      ##â€¢Show (âŠğ•©)âŠ”acc
    #}`â€¢Show <Ë˜â‰pp

    â€¢Out"  "

    #hâ†âŸ¨âŸ© â‹„ (â†•â‰ v){ hâ†©hâˆ¾âŸ¨(âˆŠğ•©)/ğ•¨âŸ©â‹„ğ•¨ }Â´ âŒ½<Ë˜gm â‹„ hâ†©âŠÂ¨â·h # h: hierarchy group list - shows the groups of corresponding children to parent. eg. âŸ¨âŸ¨0 0 1 1âŸ© âŸ¨0 1âŸ©âŸ© groups indices 0 1 to group 0 and 2 3 to group 1 in the second list. 
    #dt Draw dp

  }
  # flattens tree into list of reference lists ordered by root nodes
  { ğ•Š:
    pâ†vâ†/dt='v' â‹„ { pâ†©pâˆ¾Ë˜sâ†ğ•©âŠdp â‹„ s } _fix v 
    mâ†'o'=âŠâŸœdtË˜p â‹„ nâ†âŒˆÂ´+Â´Ë˜m # m : group objects mask in data. n
    â€¢Show p
    â€¢Show n
    â€¢Show Ë˜m
    gmâ†â‰p{ zâ†ğ•©/ğ•¨ â‹„ zâˆ¾(n-â‰ z)â¥ŠÂ¯1â†‘z }Ë˜m #gm: group path matrix - allocate data leaf variables to groups depending on their parent paths. Runs top (variable) to bottom (parent) with zero being end of parent
    dt Draw dp
    #â€¢Show m
    #â€¢Show p
    #gm â†© â‰{ ğ•©+(âŠ‘Â¯1â†‘(0â‰ ğ•©)/ğ•©)Ã—0=ğ•© }Ë˜â‰gm  # extend group paths to end and remove zeros
    #â€¢Show gm

    hâ†âŸ¨âŸ© â‹„ (â†•â‰ v){ hâ†©hâˆ¾âŸ¨(âˆŠğ•©)/ğ•¨âŸ©â‹„ğ•¨ }Â´ âŒ½<Ë˜gm â‹„ hâ†©âŠÂ¨â·h # h: hierarchy group list - shows the groups of corresponding children to parent. eg. âŸ¨âŸ¨0 0 1 1âŸ© âŸ¨0 1âŸ©âŸ© groups indices 0 1 to group 0 and 2 3 to group 1 in the second list. 
    #{
      #â€¢Show gm
      #hâ†âŸ¨âŸ© 
      #(â†•â‰ v){ 
        #â€¢Show ğ•¨
        #â€¢Show ğ•©
        #hâ†©hâˆ¾âŸ¨(âˆŠğ•©)/ğ•¨âŸ©â‹„ğ•¨ 

      #}Â´ âŒ½<Ë˜gm 


      #hâ†©âŠÂ¨â·h # h: hierarchy group list - shows the groups of corresponding children to parent. eg. âŸ¨âŸ¨0 0 1 1âŸ© âŸ¨0 1âŸ©âŸ© groups indices 0 1 to group 0 and 2 3 to group 1 in the second list. 
    #}

    eâ†dmâŠËœvâŠdp # e: matching template keys of data keys. Find the template keys that correspond to data keys in value list
    ppâ†âŸ¨âŸ© â‹„ { ppâ†©ppâˆ¾âŸ¨eâ†©âˆ¾â·Â¨ğ•©âŠ”eâŠtpâŸ© }Â¨h # pp: parent paths. Construct template parent indices of corresponding groups in h
    #{
      #eâ†dmâŠËœvâŠdp # e: matching template keys of data keys. Find the template keys that correspond to data keys in value list
      #ppâ†âŸ¨âŸ© 
      #{ 
        #â€¢Show eâŠtp
        #ppâ†©ppâˆ¾âŸ¨eâ†©âˆ¾â·Â¨ğ•©âŠ”eâŠtpâŸ© 
      #} Â¨h 
      #â€¢Show âŸ¨â†•â‰ âŸ©Â»pp
    #}
    # pp: parent paths. Construct template parent indices of corresponding groups in h
    fâ†âŠ‘h # extract first since we're initializing first level
    
    p0â†((â‰ pp)|1)â†‘1â†“pp â‹„ h0 â†((â‰ h)|1)â†‘1â†“h # case for when h and pp â‰  1 
    #p0â†((â‰ pp)|1)â†‘pp â‹„ h0 â†((â‰ h)|1)â†‘1â†“h # case for when h and pp â‰  1 

    #â€¢Show h0
    #â€¢Show p0


    #ppâ†© âŸ¨1â€¿1âŸ© âˆ¾ 2â†“pp # make sure pp groupings are kept consistent with h

    #ppâ†© Â¯1â†“pp # make sure pp groupings are kept consistent with h
    #h â†© 2â†“h # replace parent groups with already processed item since we're initializing out with children 

    â€¢Show h
    â€¢Show pp
    #ppâ†© p0 âˆ¾ 1â†“pp # make sure pp groupings are kept consistent with h

    outâ†©{ /tp=ğ•©âŠtp }Â¨âŠ‘Â¨fâŠ”dmâŠËœvâŠdp # initial setup of mapping leaf variables with siblings from parents
    #p0 { 
      #gâ†ğ•©âŠ”ğ•¨ 
      #â€¢Show out {  
        #pâŠğ•¨
      #}Â¨g
      ##oâ† Â»â‰ Â¨â·Â¨ğ•©âŠ”ğ•¨  # offsets
      #â€¢Show out
      ##â€¢Show âˆ¾o+âŠÂ¨g
    #}Â¨h0


    #outâ†© fâŠ”dmâŠËœvâŠdp # initial setup of mapping leaf variables
    #â€¢Show out

    #â€¢Show h
    #â€¢Show pp
    #â€¢Show out

    #â€¢Show /dt='k'
    #â€¢Show (/tt='k')â‰((tt='k')/tr)âŠtn
    #â€¢Show (/dt='k')â‰((dt='k')/dr)âŠdn
    ##â€¢Show (/dt='o')â‰((dt='o')/dr)âŠdn
    #â€¢Show (/dt='v')â‰((dt='v')/dr)âŠdn
    #â€¢Show (/dt='v')âŠdpâŠdp
    #(dt) Draw dp

    pp {
      # find matching template parent and inject any children
      #â€¢Show ğ•©âŠ”ğ•¨
      #â€¢Show ğ•©
      #â€¢Show ğ•¨
      #â€¢Show out
      #â€¢Show ğ•©âŠ”out
      #â€¢Show {â€¢Show {(ğ•©âŠtr)âŠtn}Â¨ğ•©}Â¨ğ•©âŠ”out
      outâ†©ğ•¨ {
        #â€¢Show ğ•©
        #â€¢Show âŠğ•¨
        #â€¢Show (âŠğ•¨)âŠ”ğ•©
        #â€¢Show (âŠğ•¨)âŠ”ğ•©
        

        sâ†ğ•© â‹„ pâ†/tp=ğ•¨âŠtp â‹„râ†ğ•¨â·p â‹„ nâ†(Â¬âˆ¨Â´ğ•¨â·âˆ¾ğ•©) # p: next parent list. r: current root position that will replace with current level references. n: number to children and number of times to duplicate current template level if the parent itself exist in parent list
        #â€¢Show "--"
        #â€¢Show ğ•¨
        #â€¢Show s
        #â€¢Show p
        #â€¢Show r
        #â€¢Show âˆ¾{âˆ¾(sÂ¨âŒ¾(râŠ¸/) p)}âŸn ğ•© # replace matching root position with its children values 
        âˆ¾{âˆ¾(sÂ¨âŒ¾(râŠ¸/) p)}âŸn ğ•© # replace matching root position with its children values 
      }Â¨ğ•©âŠ”out
    }Â¨h
  }

  # append roots and remove root keys (head of lists) which are no longer needed. r: roots, i: roots of subtrees (parts of template that have variables)
  { râ†/tp=â†•â‰ tp â‹„ iâ†âŠ‘Â¨out â‹„ bâ†1â†“Â¨out
    "processed subtrees should be roots of template tree" ! 1â‰¡âˆ§Â´iâˆŠtp
    mâ†râˆŠ(â·i) # get unprocessed root nodes only
    outâ†©âˆ¾âˆ¾((âŠi)âŠ”b)âŒ¾(mâŠ¸/) r
  }

  # insert data values into out variable and sort in correct template order
  {
    vâ†/dt='v' â‹„ pâ†dmâŠËœvâŠdp â‹„ iâ†(âŠ(vâŠdp)âŠdp) â‹„ gâ†iâŠ”p
    râ†(â‰ tr)+âˆ¾(+`Â»â‰ Â¨g)+gâŠÂ¨iâŠ”(/outâˆŠp)âŠout
    outâ†©râŒ¾((outâˆŠp)âŠ¸/) out â‹„ trâ†©trâˆ¾(â‰ tn)+â†•â‰ v â‹„ tnâ†©tnâˆ¾(dnâŠËœvâŠdr)
  }

  { outâ†©âˆ¾(outâŠtr)âŠtn} #render string result

  out
}

