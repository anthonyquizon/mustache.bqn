# Reference: http://mustache.github.io/mustache.5.html
#            https://juuso.dev/blogPosts/barbell/barbell.html
#            https://www.youtube.com/watch?v=5I4YPkVU7mY

# types
âŸ¨ none, opn_bkt, cls_bkt, hash, slash, str,     # characters
  opn_dm, cls_dm,                               # markers
  tag, opn, cls, key                            # tags

  # mark as 
âŸ© â† â†•12

labels â‡ "f    s  tock"

#v: previous value
_fix â† { Fnâ†ğ”½ â‹„ vâ†@ â‹„ {vâ†©ğ•© â‹„ Fn ğ•©} â€¢_while_ { ğ•©â‰¢v } ğ•© }

Delete â† { (/ğ•¨)(âŠ¢-â‹)(Â¬ğ•¨)/ğ•© }
Parent â‡ { gâ†âŠ”ğ•© â‹„ (â†•â‰ ğ•©) {aâ€¿wâ†ğ•¨ â‹„ (âŠâŸœa 1-Ëœaâ‹w)âŒ¾(wâŠ¸âŠ) ğ•© }Â´ (1â†“(Â»g){ğ•¨â€¿ğ•©}Â¨g) }
Depth  â† { pâ†ğ•© â‹„ dâ†pâ‰ (â†•â‰ p) â‹„ { zâ†ğ•©âŠp â‹„ d+â†©zâ‰ ğ•© â‹„ z } _Fix p â‹„ d } 
Leaf   â‡ { Â¬(â†•â‰ ğ•©)â·ğ•© }

âŸ¨DrawâŸ© â† â€¢Import "tree.bqn" 

# parse namespaces and to parent tree
ParseNs â‡ {
    ğ•Š ğ•© :  
       âŸ¨s,d,tâŸ© â† 0 ğ•Š ğ•© 
       mâ†0âŠ¸=âˆ˜â‰ Â¨s â‹„ pâ†(Parent d) 
       # remove empty strings
       râ†(â†•(â‰ s)-(â‰ /m))âŒ¾((Â¬m)âŠ¸/) (â‰ s)â¥ŠÂ¯1 â‹„ nâ† sâ†©(Â¬m)/s
       # remove duplicate strings
       râ†©(âŠn)âŒ¾((0â‰¤r)âŠ¸/) r
       nâ†© â·n 

       {ptrâ‡[p,t,r], nâ‡n};
  d ğ•Š ns : 6â‰¡â€¢Type ns ? 
    childrenâ†âˆ¾Â¨Â´{ âŸ¨âŸ¨ğ•©âŸ©, (d+1), âŸ¨'k'âŸ©âŸ© âˆ¾Â¨ (d+2) ParseNs (ns â€¢ns.Get ğ•©) } Â¨â€¢ns.Keys ns
    âŸ¨âŸ¨""âŸ©, âŸ¨dâŸ©, âŸ¨'o'âŸ©âŸ© âˆ¾Â¨ children;
  d ğ•Š ğ•© : 0â‰¡â€¢Type ğ•© ?
    { ğ•Š s : âˆ§Â´2âŠ¸â‰¡âˆ˜â€¢TypeÂ¨s ? âŸ¨âŸ¨sâŸ©, âŸ¨dâŸ©, âŸ¨'v'âŸ©âŸ© ; # parse string
      ğ•Š ğ•© : âˆ¾Â¨Â´{ (d) ParseNs ğ•©}Â¨ğ•© 
    } ğ•©;
  ğ•¨ ğ•Š ğ•© : 1â‰¡â€¢Type ğ•© ? ğ•¨ ğ•Š â€¢Fmt ğ•©
}


Parse â‡ {
  châ†ğ•© â‹„ tâ†@ â‹„ râ†@ â‹„ nâ†@ â‹„ pâ†@

  { tâ†© âˆ¨Â´âŸ¨opn_bkt,cls_bkt,hash,slashâŸ©Ã—châŠ¸=Â¨"{}#/" }                                    # tokenize character types
  { mâ†t=opn_bkt â‹„ qâ†opn_dmÃ—>âŸœÂ«m â‹„ zâ†(Â¬m)âˆ¨0<q â‹„ tâ†©z/tâŒˆq â‹„ châ†©z/ch }                     # find double opn brackets then collapse and mark into a delimeter
  { mâ†t=cls_bkt â‹„ qâ†cls_dmÃ—>âŸœÂ«m â‹„ zâ†(Â¬m)âˆ¨0<q â‹„ tâ†©z/tâŒˆq â‹„ châ†©z/ch }                     # find double close brackets then collapse and mark into a delimeter
  { mâ†câˆ¨+`(t=opn_dm)-(câ†t=cls_dm) â‹„ tâ†©tÃ—m }                                            # demote any characters outside delims as none

  # find fragments and tags. ch no longer needed
    # collapse all zeros to frags and tag names
  { mâ†t=none â‹„ sâ†>âŸœÂ» m â‹„ eâ†>âŸœÂ« m 
    zâ†(0<t)âˆ¨(0<s) â‹„ tâ†© z/tâŒˆsÃ—str â‹„ nâ†© âŠâŸœchÂ¨1â†“âŠ”mâˆ§+`s â‹„ râ†© (â†•â‰ n)âŒ¾((t=str)âŠ¸/) (â‰ t)â¥ŠÂ¯1
  }

  # TODO multiple sources

  # find tags - delete open and close and lead with tag flag
  { oâ†t=opn_dm â‹„ câ†t=cls_dm â‹„ zâ†Â¬c â‹„ tâ†©z/tâŒˆoÃ—tag â‹„ râ†©z/r }
  # mark opn tags - consume {# and set str as id (Â»Â»)
  { mâ†(t=tag)âˆ§(Â«t=hash)âˆ§(Â«Â«t=str) â‹„ zâ†Â¬âˆ¨âŸœÂ»m â‹„ tâ†©z/tâŒˆÂ»Â»mÃ—opn â‹„ râ†©z/r }
  # mark cls tags - consume {/ and set str as id (Â»Â»)
  { mâ†(t=tag)âˆ§(Â«t=slash)âˆ§(Â«Â«t=str) â‹„ zâ†Â¬âˆ¨âŸœÂ»m â‹„ tâ†©z/tâŒˆÂ»Â»mÃ—cls â‹„ râ†©z/r }
  # mark cls tags - consume { and set str as id (Â»)
  { mâ†(t=tag)âˆ§(Â«t=str) â‹„ zâ†Â¬m â‹„ tâ†©z/tâŒˆ(Â»m)Ã—key â‹„ râ†©z/r }
  # create parent vector
  { oâ†t=opn â‹„ câ†t=cls â‹„ pâ†©Parent dâ†Â»+`o-c }
  # mark opn tags as keys
  { mâ†(t=opn) â‹„ tâ†©tâŒˆmÃ—key }

  # TODO unique names

  #Delete cls tags with unused names and shift r
  { mâ†(t=cls) â‹„ zâ†Â¬m â‹„ pâ†©m Delete p â‹„ tâ†©z/t â‹„ râ†© z/r-+`Â¬z â‹„ nâ†© z/n } 


  # remove duplicate strings
   râ†©(âŠn)âŒ¾((0â‰¤r)âŠ¸/) r
  nâ†© â·n

  { ptrâ‡ [p, âŠ¢â—¶labelsÂ¨t, r] â‹„  n â‡ n }
}

Compile â‡ {
   ğ•¨ ğ•Š ğ•© : (Â¬ğ•© â€¢ns.Has "ptr") ? ğ•¨ ğ•Š (ParseNs ğ•©);
   ğ•¨ ğ•Š ğ•© : 
    âŸ¨[tp,tt,tr]â‡ptr,tnâ‡nâŸ©â†ğ•¨ â‹„ âŸ¨[dp,dt,dr]â‡ptr,dnâ‡nâŸ©â†ğ•©

    #data key parent vector. dki -> original indices
    dkp â† @ â‹„ dkr â† @ â‹„ dki â† @ 
    #template key parent vector
    tkp â† @ â‹„ tkr â† @ â‹„ tki â† @


     # create data parent vector of only keys
     {
      mâ†(dt='k')âˆ§(dp=0)
      dkpâ†©(/m)âŒ¾(mâŠ¸/) dp # set roots of keys
      dkpâ†©{ğ•©âŠdkp}âŒ¾((dt='k')âŠ¸/) dkp # remap key parents to keys
      dkpâ†©((dt='o') âˆ¨ (dt='v')) Delete dkp #delete objs and values

      dkrâ†©(dt='k')/dr
      dkiâ†©(dt='k')/â†•â‰ dt
     }

     # create template parent vector of only keys
    tkp â†© (ttâ‰ 'k') Delete tp
    tkr â†© (tt='k') / tr
    tki â†© (tt='k') / â†•â‰ tr

    # set data key indices to match template indices and remove any non existing keys
    {
      # find names that don't exist in template variables
      eâ†(tkrâŠtn)âŠ(dkrâŠdn)
      # z mask to remove all non existing data names and delete all children with deleted parents
      zâ†(â‰ tkr)=e â‹„ { zâ†©zâˆ¨(ğ•©âŠz) â‹„ ğ•©âŠdkp} _fix dkp
      # map references to names that do exist to matching template references
      mâ†âŠâŸœtkrâŒ¾(((â‰ tkr)â‰ e)âŠ¸/) e
      # delete all references that do not have a name variable in template
      # delete all children of parents of non existing vars
      dkpâ†©z Delete dkp
      dkrâ†©(Â¬z)/m
      dkiâ†©(Â¬z)/dki
    }

    # extract valid paths
    {
      PathMat â†{
        dâ†Depth ğ•©
        dmâ†d=âŒœËœâ†•âŒˆÂ´d+1 
        dmâ†© âŒˆ`Ë˜â‰+`Ë˜â‰(â†•â‰ ğ•¨)âŠ¸Ã—Ë˜dm
        âŠâŸœğ•¨Ë˜dm
      }
      â€¢Show dpm â† dkr PathMat dkp
      â€¢Show tpm â† tkr PathMat tkp
      â€¢Show dpmatch â† (<Ë˜â‰tpm)âŠ(<Ë˜â‰dpm)
      â€¢Show tpmatch â† (<Ë˜â‰dpm)âŠ(<Ë˜â‰tpm)


      # for each data at lowest find matching template

      tdâ†Depth tp
      ddâ†Depth dp

      #kâ†dt='k'
      mâ†dd=âŒˆÂ´dd # all items at max depth
      zâ†m

      #parent of children k->v -> then rematch as v
      ppâ†âŠ‘âŸœdpÂ¨/z
      ##â€¢Show (âŠ‘âŸœdpÂ¨/z)âŠdt



      #(ppâŠdr)âŠdn

      ## map to key index
      #â€¢Show pp
      #â€¢Show dki
      ## match to template depth path matrix index
      zzâ†(dkiâŠpp)âŠdpmatch

      # get surrounding sibling fragments ie same parents
      #â€¢Show zz
      #â€¢Show /â¼zz
      â€¢Show qqâ†âˆ¨Â´{ ğ•©=tp }Â¨zzâŠtkpâŠtki
      #â€¢Show zzâŠtki

      â€¢Show fgâ† ((/qq)âŠtr)âŠtn # fragments
      â€¢Show kâ† (zzâŠtkr)âŠtn
      â€¢Show vâ† (z/dr)âŠdn # values

      #â€¢Show kâŠfg
      #â€¢Show mm â† fgâˆŠk
      #â€¢Show inâ†(mm/kâŠfg)âŠ¸âŠ v
      #â€¢Show inâŒ¾(mmâŠ¸/) fg

      ## apply 

      â€¢Show cnâ† (zzâŠtkr)âŠtn
      â€¢Show crâ† â†•â‰ cn
      â€¢Show cpâ† â†•â‰ cn


      #â€¢Show ppâŠ(+`k)
      #â€¢Show ((ppâŠ(+`k))âŠdpmatch)âŠtn
      #â€¢Show pp
      #â€¢Show m

      #(âˆ¾1â†‘Â¨dt) Draw dp
      #âŸ¨ dtâŸ© Draw dp
      #({}âŒ¾((dt='k')âŠ¸/) âˆ¾1â†‘Â¨dt) Draw dp

      #(âˆ¾1â†‘Â¨dkrâŠtn) Draw dkp
      #â€¢Show (z/1-Ëœ+`v)âŠdpmatch
      #â€¢Show ((z/1-Ëœ+`k)âŠtpmatch)

      #â€¢Show (((z/1-Ëœ+`k)âŠtpmatch)âŠdki)
      #â€¢Show câ†âˆ¨Â´dpâŠ¸=Â¨(((z/1-Ëœ+`k)âŠtpmatch)âŠdki) # find children with these parents


      #â€¢Show ((z/1-Ëœ+`k)âŠtkr)âŠtn

      #â€¢Show (((z/1-Ëœ+`k)âŠtpmatch)âŠtn)

      #â€¢Show keys â† âŠ‘âŸœdpÂ¨(((z/1-Ëœ+`k)âŠtpmatch)âŠdki) # template keys matching to data key index

      #{
        ## find all items with parent index
        #â€¢Show pâ†ğ•©âŠ‘dp
        #tâ† pâŠ‘dt

      #}Â¨(((z/1-Ëœ+`k)âŠtpmatch)âŠdki) # template keys matching to data key index

      #(âˆ¾1â†‘Â¨dkrâŠtn) Draw dkp

      #r â† tr(âŠ¢/Ã—)z # references for current depth

      #â€¢Show z

    }


    #{ ğ•Š:

      #â€¢Show tpm
      #â€¢Show tpmatch

      #â€¢Show dpm
      #â€¢Show dpmatch

      #â€¢Show kâ†tt='k'
      #â€¢Show mâ†d=âŒˆÂ´d
      #â€¢Show zâ†(mâˆ§k)
      #r â†tr(âŠ¢/Ã—)z # references for current depth
      
      #â€¢Show tnâŠËœtr(âŠ¢/Ã—)z
      #â€¢Show /(zÃ—tr)/tn

      #â€¢Show dâ‰tkp
      ## while


      # get children of depth x
        # get parent
          # separate to parent
            # parent key is now children rendered
          

      #â€¢Show (mâˆ§k)Ã—tpâŠtp
      # replace 
      #â€¢Show âŒ¾((0>z)âŠ¸/) z
    #}




    #{
      #dâ†Depth dkp
      #dmâ†d=âŒœËœâ†•âŒˆÂ´d+1 
      #â€¢Show dkr
      #â€¢Show dm
      #â€¢Show â‰+`Ë˜â‰dm
      ##â€¢Show {  âŠâŒ¾(ğ•©âŠ¸/) dkr}Ë˜dm
    #}

    #{
      #dâ†Depth tkp
      #â€¢Show tkr
      #dmâ†d=âŒœËœâ†•âŒˆÂ´d+1 
      #â€¢Show dm
      ##â€¢Show {(â‰ d)â†‘ğ•©/tkr}Ë˜dm
    #}
    #(0âŠ¸âŠÂ¨tkr) Draw tkp
    #({0âŠ‘ğ•©âŠ‘tn}Â¨tkr)  Draw tkp

       
    #(0âŠ¸âŠ‘Â¨(dt='k')âŠdn)Draw dkp

    #â€¢Show tkr âŠ tn
    #Draw tkp
    #tt Draw tp
    #â€¢Show mâ†dt='k'
    #â€¢Show mâ†dt='v'
    #â€¢Show m/dt
    #(m/dt) Draw m Delete dpâŠdp

    #{ dâ† Depth dp â‹„ â€¢Show d=âŒœËœâ†•âŒˆÂ´d+1 }
    #{ dâ† Depth tp â‹„ â€¢Show d=âŒœËœâ†•âŒˆÂ´d+1 }

    #â€¢Show (((dt='k')/dr)âŠdn)
    #â€¢Show (((tt='k')/tr)âŠtn)
    #â€¢Show (((dt='k')/dr)âŠdn)âˆŠ((tt='k')/tr)âŠtn

    #{
      #mâ† dt='k'

      #dt Draw dp
      #(m/dt) Draw m/dpâŠdp
    #}
    #tdâ† Depth tp
    #â€¢Show tr

    #dv â† ((dt='k')/dr)âŠdn
    #tvâ† (((tt='v')âˆ¨(tt='o'))/tr)âŠtn # variable names

    #dt Draw dp
    ## TODO check existence by depth
    #â€¢Show dvâ€¿tv
    #â€¢Show dvâˆŠtv
    # create key tree
    #dt Draw dp
}



#Compile0 â† {
  ## ip: replace parent, rv: replace values, r: references, t: types, p: parent, ch: characters, n: names
  #ipâ€¿rv â† ğ•¨ â‹„ rn â† (â‰ ip)â¥ŠÂ¯1 â‹„ ch â† â€¢file.Chars ğ•© â‹„ r â† (â‰ ch)â¥ŠÂ¯1 â‹„ t â† p â† (â‰ ch)â¥Š0 â‹„ n â† @

  #Print â† { ğ•Š: â€¢Show [ip, rv, rn] â‹„ â€¢Show [p, t, r] â‹„ â€¢Show n }

  #oâ€¿c â† {âˆ¨âŸœÂ»âŸ(1-Ëœâ‰ ğ•©)(â‰ ch)â†‘ğ•©â·ch}Â¨opnâ€¿cls               # get open and close enclose bits
  #t â†© +`(Â»>âŸœÂ«o)+-(Â»âŠ¸<c)                               # pass: mark names in types
  #d â† (Â¬oâˆ¨c) â‹„ ch dâŠ¸/ â†© â‹„ p dâŠ¸/ â†© â‹„ t dâŠ¸/ â†© â‹„ r dâŠ¸/ â†© # pass: remove brackets

  ## pass: names to '$' tags with types and references to original names
  #{
    #i â† (0âŠ¸â‰ â‰ Â¨)âŠ¸/âŠ”(âŠ¢-ËœÂ¬Ã—+`)Â¬t=types.b

    #nm â† (Â¬âˆŠâŸœ"#/")âŠ¸/Â¨ âŠâŸœchÂ¨i # names: extracted tag strings
    #b â† (â‰ ch)â†‘(/â¼0âŠ‘Â¨i) # base tags - opn of tags
    #s â† types.sÃ—bâˆ§ch='#' # opn tags
    #e â† types.eÃ—bâˆ§ch='/' # cls tags
    #d â† (t=types.b)Ã—Â¬b

    #rn â†© Â¯1Â¨âŒ¾(((â‰ nm)=nmâŠrv)âŠ¸/) nmâŠrv
    #n  â†© (â‰âŸœâŠ) nm
    #r  â†© (Â¬d)/(âŠnm)âŒ¾(bâŠ¸/) r
    #p  â†© d Delete p
    #t  â†© (Â¬d)/âŒˆÂ´bâ€¿sâ€¿e
    #ch â†© (Â¬d)/'$'Â¨âŒ¾(bâŠ¸/) ch
  #}


  #p â†© +`(Â»>âŸœÂ«(t=types.s))+-(Â»âŠ¸<(t=types.e))           # pass: construct parents from opn/cls tags

  #Print @
#}
