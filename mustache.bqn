# Reference: http://mustache.github.io/mustache.5.html
#            https://juuso.dev/blogPosts/barbell/barbell.html
#            https://www.youtube.com/watch?v=5I4YPkVU7mY

# types
âŸ¨ none, opn_bkt, cls_bkt, hash, slash, str, bang,     # characters
  opn_dm, cls_dm,                   # markers
  tag, opn, cls, key                                  # tags
âŸ© â† â†•13

labels â‡ âˆ¾âŸ¨
  "f......",
  "..",
  "tock"
âŸ©

#p: previous value
_fix â† { Fnâ†ğ”½ â‹„ pâ†@ â‹„ {râ†p Fn ğ•© â‹„ pâ†©ğ•© â‹„ r} â€¢_while_ { ğ•©â‰¢p } ğ•© â‹„ p }

Delete â† { (/ğ•¨)(âŠ¢-â‹)(Â¬ğ•¨)/ğ•© }
Parent â‡ { gâ†âŠ”ğ•© â‹„ (â†•â‰ ğ•©) {aâ€¿wâ†ğ•¨ â‹„ (âŠâŸœa 1-Ëœaâ‹w)âŒ¾(wâŠ¸âŠ) ğ•© }Â´ (1â†“(Â»g){ğ•¨â€¿ğ•©}Â¨g) }
Depth  â† { pâ†ğ•© â‹„ dâ†pâ‰ (â†•â‰ p) â‹„ { zâ†ğ•©âŠp â‹„ d+â†©zâ‰ ğ•© â‹„ z } _Fix p â‹„ d } 
Leaf   â‡ { Â¬(â†•â‰ ğ•©)â·ğ•© }

âŸ¨DrawâŸ© â† â€¢Import "tree.bqn" 

# parse namespaces and to parent tree
ParseNs â‡ {
    ğ•Š ğ•© :  
       âŸ¨s,d,tâŸ© â† 0 ğ•Š ğ•© 
       mâ†0âŠ¸=âˆ˜â‰ Â¨s â‹„ pâ†(Parent d) 
       # remove empty strings
       râ†(â†•(â‰ s)-(â‰ /m))âŒ¾((Â¬m)âŠ¸/) (â‰ s)â¥ŠÂ¯1 â‹„ nâ† sâ†©(Â¬m)/s
       # remove duplicate strings
       râ†©(âŠn)âŒ¾((0â‰¤r)âŠ¸/) r
       nâ†© â·n 

       {ptrâ‡[p,t,r], nâ‡n};
  d ğ•Š ns : 6â‰¡â€¢Type ns ? 
    childrenâ†âˆ¾Â¨Â´{ âŸ¨âŸ¨ğ•©âŸ©, (d+1), âŸ¨'k'âŸ©âŸ© âˆ¾Â¨ (d+2) ParseNs (ns â€¢ns.Get ğ•©) } Â¨â€¢ns.Keys ns
    âŸ¨âŸ¨""âŸ©, âŸ¨dâŸ©, âŸ¨'o'âŸ©âŸ© âˆ¾Â¨ children;
  d ğ•Š ğ•© : 0â‰¡â€¢Type ğ•© ?
    { ğ•Š s : âˆ§Â´2âŠ¸â‰¡âˆ˜â€¢TypeÂ¨s ? âŸ¨âŸ¨sâŸ©, âŸ¨dâŸ©, âŸ¨'v'âŸ©âŸ© ; # parse string
      ğ•Š ğ•© : âˆ¾Â¨Â´{ (d) ParseNs ğ•©}Â¨ğ•© 
    } ğ•©;
  ğ•¨ ğ•Š ğ•© : 1â‰¡â€¢Type ğ•© ? ğ•¨ ğ•Š â€¢Fmt ğ•©
}


Parse â‡ {
  châ†ğ•© â‹„ tâ†@ â‹„ râ†@ â‹„ nâ†@ â‹„ pâ†@

  { tâ†© âˆ¨Â´âŸ¨opn_bkt,cls_bkt,hash,slashâŸ©Ã—châŠ¸=Â¨"{}#/" }                                    # tokenize character types
  { mâ†t=opn_bkt â‹„ qâ†opn_dmÃ—>âŸœÂ«m â‹„ zâ†(Â¬m)âˆ¨0<q â‹„ tâ†©z/tâŒˆq â‹„ châ†©z/ch }                     # find double opn brackets then collapse and mark into a delimeter
  { mâ†t=cls_bkt â‹„ qâ†cls_dmÃ—>âŸœÂ«m â‹„ zâ†(Â¬m)âˆ¨0<q â‹„ tâ†©z/tâŒˆq â‹„ châ†©z/ch }                     # find double close brackets then collapse and mark into a delimeter
  { mâ†câˆ¨+`(t=opn_dm)-(câ†t=cls_dm) â‹„ tâ†©tÃ—m }                                            # demote any characters outside delims as none

  # find fragments and tags. ch no longer needed
    # collapse all zeros to frags and tag names
  { mâ†t=none â‹„ sâ†>âŸœÂ» m â‹„ eâ†>âŸœÂ« m 
    zâ†(0<t)âˆ¨(0<s) â‹„ tâ†© z/tâŒˆsÃ—str â‹„ nâ†© âŠâŸœchÂ¨1â†“âŠ”mâˆ§+`s â‹„ râ†© (â†•â‰ n)âŒ¾((t=str)âŠ¸/) (â‰ t)â¥ŠÂ¯1
  }

  # TODO multiple sources

  # remove comments
  #{ 
    #oâ†(t=opn_dm)âˆ§(Â«t=bang) 
    #câ†(t=cls_dm)
    #mâ†`o-c
    #â€¢Show m

    ##â‹„ zâ†Â¬âˆ¨âŸœÂ»m â‹„ tâ†©z/tâŒˆÂ»Â»mÃ—opn_com â‹„ râ†©z/r 
    #}

  { oâ†t=opn_dm â‹„ câ†t=cls_dm â‹„ zâ†Â¬c â‹„ tâ†©z/tâŒˆoÃ—tag â‹„ râ†©z/r } # find tags - delete open and close and lead with tag flag
  { mâ†(t=tag)âˆ§(Â«t=hash)âˆ§(Â«Â«t=str) â‹„ zâ†Â¬âˆ¨âŸœÂ»m â‹„ tâ†©z/tâŒˆÂ»Â»mÃ—opn â‹„ râ†©z/r } # mark opn tags - consume {# and set str as id (Â»Â»)
  { mâ†(t=tag)âˆ§(Â«t=slash)âˆ§(Â«Â«t=str) â‹„ zâ†Â¬âˆ¨âŸœÂ»m â‹„ tâ†©z/tâŒˆÂ»Â»mÃ—cls â‹„ râ†©z/r } # mark cls tags - consume {/ and set str as id (Â»Â»)
  { mâ†(t=tag)âˆ§(Â«t=str) â‹„ zâ†Â¬m â‹„ tâ†©z/tâŒˆ(Â»m)Ã—key â‹„ râ†©z/r } # mark cls tags - consume { and set str as id (Â»)
  { oâ†t=opn â‹„ câ†t=cls â‹„ pâ†©Parent dâ†Â»+`o-c } # create parent vector
  { mâ†(t=opn) â‹„ tâ†©tâŒˆmÃ—key } # mark opn tags as keys

  # TODO unique names

  { mâ†(t=cls) â‹„ zâ†Â¬m â‹„ pâ†©m Delete p â‹„ tâ†©z/t â‹„ râ†© z/r-+`Â¬z â‹„ nâ†© z/n } #Delete cls tags with unused names and shift r

  # remove duplicate strings
   râ†©(âŠn)âŒ¾((0â‰¤r)âŠ¸/) r
  nâ†© â·n

  { ptrâ‡ [p, âŠ¢â—¶labelsÂ¨t, r] â‹„  n â‡ n }
}

PathMat â† { pâ†ğ•¨ â‹„ pmâ†ğ•© â‹„ {qâ†ğ•©âŠp â‹„ pm â†©pmâˆ¾Ë˜q â‹„ q} _Fix pm â‹„ Â¯1â†“Ë˜pm }
#GroupIn â† { 1-Ëœğ•©/+`>âŸœÂ»ğ•© }

# TODO rename n to s
Compile â‡ {
 ğ•¨ ğ•Š ğ•© : (Â¬ğ•© â€¢ns.Has "ptr") ? ğ•¨ ğ•Š (ParseNs ğ•©);
 ğ•¨ ğ•Š ğ•© : 
  âŸ¨[tp,tt,tr]â‡ptr,tnâ‡nâŸ©â†ğ•¨ â‹„ âŸ¨[dp,dt,dr]â‡ptr,dnâ‡nâŸ©â†ğ•©
  knâ†((tt='k')/tr)âŠtn #shared keys
  dmâ†@ â‹„ tmâ†@ # key match indices
  tkâ†@ â‹„ dkâ†@
  rpâ†âŸ¨âŸ©â‹„rrâ†âŸ¨âŸ©â‹„rnâ†âŸ¨âŸ©

  { kâ†(((tt='k')/tr)âŠtn) â‹„ tkâ†©Â¯1Â¨tr â‹„ tkâ†©(knâŠk)âŒ¾((tt='k')âŠ¸/) tk }
  # remap data key reference names to shared reference names to have common indices
  { kâ†(((dt='k')/dr)âŠdn) â‹„ dkâ†©Â¯1Â¨dr â‹„ dkâ†©(knâŠk)âŒ¾((dt='k')âŠ¸/) dk }
  # create find matching reference paths from keys. 
  # ie foo->bar->baz in data matches with foo->bar->baz in template rather than foo->bar->quux
  {
    trpâ† âŠâŸœtkË˜tp PathMat /(tt='k') â‹„ nâ†1âŠ‘â‰¢trp # trp: template reference paths
    drpâ† âŠâŸœdkË˜{ mâ†ğ•©/Ëœ'k'=ğ•©âŠdt â‹„ nâ†‘mâˆ¾nâ¥ŠâŠ‘âŒ½m }Ë˜ dp PathMat /(dt='k') # drp: data reference paths
    ksâ†trpâŠ¸âŠË˜drp â‹„ kâ†/tt='k' â‹„ mâ†ksâ‰ â‰ k â‹„ ksâ†©(âŠâŸœk)âŒ¾(mâŠ¸/) ks â‹„ ksâ†©Â¯1Â¨âŒ¾((Â¬m)âŠ¸/) ks #convert keyspace to normal index space with Â¯1 as non index
    dmâ†©ksâŒ¾((dt='k')âŠ¸/) Â¯1Â¨dt  # mappings from data keys to template keys Â¯1 if not a key
  }

  # prune key strings that don't exist path matrix ie don't exist as a tempalate variable. Helps with debuhing
  {
    zâ†(dt='k')âˆ§(dm=Â¯1) â‹„ { zâ†©zâˆ¨(ğ•©âŠz) â‹„ ğ•©âŠdp} _fix dp # mark unused data variables and remove orphanded children
    dpâ†©z Delete dp â‹„ dtâ†©(Â¬z)/dt â‹„ drâ†©(Â¬z)/dr â‹„ dmâ†©(Â¬z)/dm
  }

  Draw dp
  #Draw tp
  #find leaf groups get 

  aâ†@
  {
    pâ†vâ†/dt='v' â‹„ { pâ†©pâˆ¾Ë˜sâ†ğ•©âŠdp â‹„ s } _fix v â‹„ pâ†©Â¯1â†“Ë˜p 
    mâ†'o'=âŠâŸœdtË˜p â‹„ â€¢Show nâ†âŒˆÂ´+Â´Ë˜m
    gmâ†â‰p{ zâ†ğ•©/ğ•¨ â‹„ zâˆ¾(n-â‰ z)â¥ŠÂ¯1â†‘z }Ë˜m

    # TODO order keys correctly

    â€¢Show gm
    # extend group paths to end
    gm â†© â‰{ ğ•©+(âŠ‘Â¯1â†‘(0â‰ ğ•©)/ğ•©)Ã—0=ğ•© }Ë˜â‰gm
    kâ†(1â†‘<Ë˜gm)âŠ”eâ†dmâŠËœvâŠdp
    hâ†âŸ¨âŸ© â‹„ (â†•â‰ v){ hâ†©hâˆ¾âŸ¨(âˆŠğ•©)/ğ•¨âŸ©â‹„ğ•¨ }Â´ âŒ½Â¯1â†“<Ë˜gm â‹„ # hierarchy list drop root - handle that as different case 
    â€¢Show gm
    hâ†©âŠÂ¨â·h

    ##pâ†{ pâ†âŸ¨âŸ© â‹„ { xâ†âŠ‘ğ•©âŠtp â‹„ pâ†©pâˆ¾x â‹„ x } _fix ğ•© â‹„ pâ†©Â¯1â†“p }Â¨g
    ##â€¢Show h
    ##ppâ†âŸ¨âŸ© â‹„ { ppâ†©ppâˆ¾âŸ¨sâ†ğ•©âŠtpâŸ©â‹„s } _Fix âŠ‘Â¨k â‹„ ppâ†©pp# template parent path

    ppathâ†âŸ¨âŸ©
    { 
      ppathâ†©ppathâˆ¾âŸ¨eâ†©âˆ¾â·Â¨ğ•©âŠ”eâŠtpâŸ© 
    }Â¨h


    fâ†âŠ‘h
    hâ†©1â†“h
    ppathâ†©1â†“ppath

    â€¢Show h
    â€¢Show ppath
    #â€¢Show k
    ###â€¢Show aâ†{/tp=ğ•©}Â¨âŠ‘ppath
    â€¢Show aâ†©{/tp=ğ•©âŠtp}Â¨âŠ‘Â¨fâŠ”dmâŠËœvâŠdp

    â€¢Show "=+++++++++="
    (ppath) {
      â€¢Show "--"
      â€¢Show ğ•¨â€¿ğ•©
      â€¢Show a
      â€¢Show ğ•¨
      â€¢Show ğ•©âŠ”a
      aâ†©ğ•¨ {
        â€¢Show "+"
        â€¢Show "ğ•¨"â€¿ğ•¨â€¿"ğ•©"â€¿ğ•©
        â€¢Show pâ†/tp=ğ•¨âŠtp
        â€¢Show râ†ğ•¨â·p
        â€¢Show Â¬âˆ¨Â´ğ•¨â·âˆ¾ğ•©
        nâ†(Â¬âˆ¨Â´ğ•¨â·âˆ¾ğ•©)
        â€¢Show n
        sâ†ğ•©
        #â€¢Show "b" â€¿b
        â€¢Show zâ†âˆ¾{âˆ¾(sÂ¨âŒ¾(râŠ¸/) p)}âŸn ğ•©
        z
      }Â¨ğ•©âŠ”a

      #â€¢Show ((âˆ¾a)âŠtr)âŠtn
    }Â¨h
    #â€¢Show (a)
  }

  # append roots and remove root keys from a
  {
    râ†/tp=â†•â‰ tp
    iâ†âŠ‘Â¨a
    bâ†1â†“Â¨a
    
    mâ†râˆŠ(â·i)
    aâ†©âˆ¾âˆ¾((âŠi)âŠ”b)âŒ¾(mâŠ¸/) r
  }

  # insert values 
  {
    vâ†/dt='v' 
    pâ†dmâŠËœvâŠdp
    râ†(pâŠ(/aâˆŠp)âŠa)âŠ(â‰ tr)+â†•â‰ v # reorder values to match template order rather than data order
    aâ†©râŒ¾((aâˆŠp)âŠ¸/) a
    trâ†©trâˆ¾(â‰ tn)+â†•â‰ v
    tnâ†©tnâˆ¾(dnâŠËœvâŠdr)
  }

  { aâ†©âˆ¾(aâŠtr)âŠtn} #render string result

  a
}

