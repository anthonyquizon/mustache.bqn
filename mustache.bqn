# Reference: http://mustache.github.io/mustache.5.html
#            https://juuso.dev/blogPosts/barbell/barbell.html
#            https://www.youtube.com/watch?v=5I4YPkVU7mY

# types
âŸ¨ none, opn_bkt, cls_bkt, hash, slash, str, bang,     # characters
  opn_dm, cls_dm,                   # markers
  tag, opn, cls, key                                  # tags
âŸ© â† â†•13

labels â‡ âˆ¾âŸ¨
  "f......",
  "..",
  "tock"
âŸ©

#p: previous value
_fix â† { Fnâ†ğ”½ â‹„ pâ†@ â‹„ {râ†p Fn ğ•© â‹„ pâ†©ğ•© â‹„ r} â€¢_while_ { ğ•©â‰¢p } ğ•© â‹„ p }

Delete â† { (/ğ•¨)(âŠ¢-â‹)(Â¬ğ•¨)/ğ•© }
Parent â‡ { gâ†âŠ”ğ•© â‹„ (â†•â‰ ğ•©) {aâ€¿wâ†ğ•¨ â‹„ (âŠâŸœa 1-Ëœaâ‹w)âŒ¾(wâŠ¸âŠ) ğ•© }Â´ (1â†“(Â»g){ğ•¨â€¿ğ•©}Â¨g) }
Depth  â† { pâ†ğ•© â‹„ dâ†pâ‰ (â†•â‰ p) â‹„ { zâ†ğ•©âŠp â‹„ d+â†©zâ‰ ğ•© â‹„ z } _Fix p â‹„ d } 
Leaf   â‡ { Â¬(â†•â‰ ğ•©)â·ğ•© }

âŸ¨DrawâŸ© â† â€¢Import "tree.bqn" 

# parse namespaces and to parent tree
ParseNs â‡ {
    ğ•Š ğ•© :  
       âŸ¨s,d,tâŸ© â† 0 ğ•Š ğ•© 
       mâ†0âŠ¸=âˆ˜â‰ Â¨s â‹„ pâ†(Parent d) 
       # remove empty strings
       râ†(â†•(â‰ s)-(â‰ /m))âŒ¾((Â¬m)âŠ¸/) (â‰ s)â¥ŠÂ¯1 â‹„ nâ† sâ†©(Â¬m)/s
       # remove duplicate strings
       râ†©(âŠn)âŒ¾((0â‰¤r)âŠ¸/) r
       nâ†© â·n 

       {ptrâ‡[p,t,r], nâ‡n};
  d ğ•Š ns : 6â‰¡â€¢Type ns ? 
    childrenâ†âˆ¾Â¨Â´{ âŸ¨âŸ¨ğ•©âŸ©, (d+1), âŸ¨'k'âŸ©âŸ© âˆ¾Â¨ (d+2) ParseNs (ns â€¢ns.Get ğ•©) } Â¨â€¢ns.Keys ns
    âŸ¨âŸ¨""âŸ©, âŸ¨dâŸ©, âŸ¨'o'âŸ©âŸ© âˆ¾Â¨ children;
  d ğ•Š ğ•© : 0â‰¡â€¢Type ğ•© ?
    { ğ•Š s : âˆ§Â´2âŠ¸â‰¡âˆ˜â€¢TypeÂ¨s ? âŸ¨âŸ¨sâŸ©, âŸ¨dâŸ©, âŸ¨'v'âŸ©âŸ© ; # parse string
      ğ•Š ğ•© : âˆ¾Â¨Â´{ (d) ParseNs ğ•©}Â¨ğ•© 
    } ğ•©;
  ğ•¨ ğ•Š ğ•© : 1â‰¡â€¢Type ğ•© ? ğ•¨ ğ•Š â€¢Fmt ğ•©
}


Parse â‡ {
  châ†ğ•© â‹„ tâ†@ â‹„ râ†@ â‹„ nâ†@ â‹„ pâ†@

  { tâ†© âˆ¨Â´âŸ¨opn_bkt,cls_bkt,hash,slashâŸ©Ã—châŠ¸=Â¨"{}#/" }                                    # tokenize character types
  { mâ†t=opn_bkt â‹„ qâ†opn_dmÃ—>âŸœÂ«m â‹„ zâ†(Â¬m)âˆ¨0<q â‹„ tâ†©z/tâŒˆq â‹„ châ†©z/ch }                     # find double opn brackets then collapse and mark into a delimeter
  { mâ†t=cls_bkt â‹„ qâ†cls_dmÃ—>âŸœÂ«m â‹„ zâ†(Â¬m)âˆ¨0<q â‹„ tâ†©z/tâŒˆq â‹„ châ†©z/ch }                     # find double close brackets then collapse and mark into a delimeter
  { mâ†câˆ¨+`(t=opn_dm)-(câ†t=cls_dm) â‹„ tâ†©tÃ—m }                                            # demote any characters outside delims as none

  # find fragments and tags. ch no longer needed
    # collapse all zeros to frags and tag names
  { mâ†t=none â‹„ sâ†>âŸœÂ» m â‹„ eâ†>âŸœÂ« m 
    zâ†(0<t)âˆ¨(0<s) â‹„ tâ†© z/tâŒˆsÃ—str â‹„ nâ†© âŠâŸœchÂ¨1â†“âŠ”mâˆ§+`s â‹„ râ†© (â†•â‰ n)âŒ¾((t=str)âŠ¸/) (â‰ t)â¥ŠÂ¯1
  }

  # TODO multiple sources

  # remove comments
  #{ 
    #oâ†(t=opn_dm)âˆ§(Â«t=bang) 
    #câ†(t=cls_dm)
    #mâ†`o-c
    #â€¢Show m

    ##â‹„ zâ†Â¬âˆ¨âŸœÂ»m â‹„ tâ†©z/tâŒˆÂ»Â»mÃ—opn_com â‹„ râ†©z/r 
    #}

  # find tags - delete open and close and lead with tag flag
  { oâ†t=opn_dm â‹„ câ†t=cls_dm â‹„ zâ†Â¬c â‹„ tâ†©z/tâŒˆoÃ—tag â‹„ râ†©z/r }
  # mark opn tags - consume {# and set str as id (Â»Â»)
  { mâ†(t=tag)âˆ§(Â«t=hash)âˆ§(Â«Â«t=str) â‹„ zâ†Â¬âˆ¨âŸœÂ»m â‹„ tâ†©z/tâŒˆÂ»Â»mÃ—opn â‹„ râ†©z/r }
  # mark cls tags - consume {/ and set str as id (Â»Â»)
  { mâ†(t=tag)âˆ§(Â«t=slash)âˆ§(Â«Â«t=str) â‹„ zâ†Â¬âˆ¨âŸœÂ»m â‹„ tâ†©z/tâŒˆÂ»Â»mÃ—cls â‹„ râ†©z/r }
  # mark cls tags - consume { and set str as id (Â»)
  { mâ†(t=tag)âˆ§(Â«t=str) â‹„ zâ†Â¬m â‹„ tâ†©z/tâŒˆ(Â»m)Ã—key â‹„ râ†©z/r }
  # create parent vector
  { oâ†t=opn â‹„ câ†t=cls â‹„ pâ†©Parent dâ†Â»+`o-c }
  # mark opn tags as keys
  { mâ†(t=opn) â‹„ tâ†©tâŒˆmÃ—key }

  # TODO unique names

  #Delete cls tags with unused names and shift r
  { mâ†(t=cls) â‹„ zâ†Â¬m â‹„ pâ†©m Delete p â‹„ tâ†©z/t â‹„ râ†© z/r-+`Â¬z â‹„ nâ†© z/n } 


  # remove duplicate strings
   râ†©(âŠn)âŒ¾((0â‰¤r)âŠ¸/) r
  nâ†© â·n

  { ptrâ‡ [p, âŠ¢â—¶labelsÂ¨t, r] â‹„  n â‡ n }
}

PathMat â† { pâ†ğ•¨ â‹„ pmâ†ğ•© â‹„ {qâ†ğ•©âŠp â‹„ pm â†©pmâˆ¾Ë˜q â‹„ q} _Fix pm â‹„ Â¯1â†“Ë˜pm }
#GroupIn â† { 1-Ëœğ•©/+`>âŸœÂ»ğ•© }

# TODO rename n to s
Compile â‡ {
 ğ•¨ ğ•Š ğ•© : (Â¬ğ•© â€¢ns.Has "ptr") ? ğ•¨ ğ•Š (ParseNs ğ•©);
 ğ•¨ ğ•Š ğ•© : 
  âŸ¨[tp,tt,tr]â‡ptr,tnâ‡nâŸ©â†ğ•¨ â‹„ âŸ¨[dp,dt,dr]â‡ptr,dnâ‡nâŸ©â†ğ•©
  knâ†((tt='k')/tr)âŠtn #shared keys
  dmâ†@ â‹„ tmâ†@ # key match indices
  tkâ†@ â‹„ dkâ†@
  rpâ†âŸ¨âŸ©â‹„rrâ†âŸ¨âŸ©â‹„rnâ†âŸ¨âŸ©

  { kâ†(((tt='k')/tr)âŠtn) â‹„ tkâ†©Â¯1Â¨tr â‹„ tkâ†©(knâŠk)âŒ¾((tt='k')âŠ¸/) tk }
  # remap data key reference names to shared reference names to have common indices
  { kâ†(((dt='k')/dr)âŠdn) â‹„ dkâ†©Â¯1Â¨dr â‹„ dkâ†©(knâŠk)âŒ¾((dt='k')âŠ¸/) dk }
  # create find matching reference paths from keys. 
  # ie foo->bar->baz in data matches with foo->bar->baz in template rather than foo->bar->quux
  {
    trpâ† âŠâŸœtkË˜tp PathMat /(tt='k') â‹„ nâ†1âŠ‘â‰¢trp # trp: template reference paths
    drpâ† âŠâŸœdkË˜{ mâ†ğ•©/Ëœ'k'=ğ•©âŠdt â‹„ nâ†‘mâˆ¾nâ¥ŠâŠ‘âŒ½m }Ë˜ dp PathMat /(dt='k') # drp: data reference paths
    ksâ†trpâŠ¸âŠË˜drp â‹„ kâ†/tt='k' â‹„ mâ†ksâ‰ â‰ k â‹„ ksâ†©(âŠâŸœk)âŒ¾(mâŠ¸/) ks â‹„ ksâ†©Â¯1Â¨âŒ¾((Â¬m)âŠ¸/) ks #convert keyspace to normal index space with Â¯1 as non index
    dmâ†©ksâŒ¾((dt='k')âŠ¸/) Â¯1Â¨dt  # mappings from data keys to template keys Â¯1 if not a key
  }

  # prune key strings that don't exist path matrix ie don't exist as a tempalate variable. Helps with debuhing
  {
    zâ†(dt='k')âˆ§(dm=Â¯1) â‹„ { zâ†©zâˆ¨(ğ•©âŠz) â‹„ ğ•©âŠdp} _fix dp # mark unused data variables and remove orphanded children
    dpâ†©z Delete dp â‹„ dtâ†©(Â¬z)/dt â‹„ drâ†©(Â¬z)/dr â‹„ dmâ†©(Â¬z)/dm
  }

  Draw dp
  #Draw tp
  #find leaf groups get 

  {
    pâ†vâ†/dt='v' â‹„ { pâ†©pâˆ¾Ë˜sâ†ğ•©âŠdp â‹„ s } _fix v â‹„ pâ†©Â¯1â†“Ë˜p 
    mâ†'o'=âŠâŸœdtË˜p â‹„ â€¢Show nâ†âŒˆÂ´+Â´Ë˜m
    gmâ†â·âŠË˜â‰p{ zâ†ğ•©/ğ•¨ â‹„ zâˆ¾(n-â‰ z)â¥ŠÂ¯1â†‘z }Ë˜m

    # TODO order keys correctly

    kâ†(1â†‘<Ë˜gm)âŠ”eâ†dmâŠËœvâŠdp
    hâ†âŸ¨âŸ© â‹„ (â†•â‰ v){ hâ†©hâˆ¾âŸ¨(âˆŠğ•©)/ğ•¨âŸ©â‹„ğ•¨ }Â´ âŒ½Â¯1â†“<Ë˜gm â‹„ # hierarchy list drop root - handle that as different case 

    #pâ†{ pâ†âŸ¨âŸ© â‹„ { xâ†âŠ‘ğ•©âŠtp â‹„ pâ†©pâˆ¾x â‹„ x } _fix ğ•© â‹„ pâ†©Â¯1â†“p }Â¨g
    #â€¢Show h
    #ppâ†âŸ¨âŸ© â‹„ { ppâ†©ppâˆ¾âŸ¨sâ†ğ•©âŠtpâŸ©â‹„s } _Fix âŠ‘Â¨k â‹„ ppâ†©pp# template parent path

    ppathâ†âŸ¨âŸ©
    { 
      ppathâ†©ppathâˆ¾âŸ¨eâ†©âˆ¾â·Â¨ğ•©âŠ”eâŠtpâŸ© 
    }Â¨h

    â€¢Show hâ†©1â†“h
    â€¢Show ppathâ†©1â†“ppath
    â€¢Show k
    #â€¢Show aâ†{/tp=ğ•©}Â¨âŠ‘ppath
    â€¢Show aâ†{/tp=ğ•©âŠtp}Â¨âŠ‘Â¨k

    (ppath) {
      â€¢Show "--"
      â€¢Show ğ•¨â€¿ğ•©
      aâ†©â€¢Show ğ•¨ {
        â€¢Show "+"
        â€¢Show ğ•©
        â€¢Show pâ†/tp=ğ•¨âŠtp
        #â€¢Show sâ†
        â€¢Show râ†(ğ•¨â·p)
        â€¢Show zâ†âˆ¾âˆ¾(ğ•©Â¨âŒ¾(râŠ¸/) p)
      }Â¨ğ•©âŠ”a

      #â€¢Show (a)
      #â€¢Show ((âˆ¾a)âŠtr)âŠtn
      #â€¢SHow (aâŠtr)âŠtn
    }Â¨h

      â€¢Show (((1=âˆ¾a)/âˆ¾a)âŠtr)âŠtn
      â€¢Show ((âˆ¾a)âŠtr)âŠtn

    #pp {
      #pâ†ğ•¨
      #â€¢Show "--"
      #â€¢Show ğ•¨â€¿ğ•©
      #â€¢Show ğ•©âŠ”k
      #â€¢Show kâ†©âˆ¾Â¨ğ•¨ {
        #â€¢Show ğ•¨â€¿ğ•©
        #(/tp=ğ•¨)Â¨ğ•©
      #} Â¨ ğ•©âŠ”k
      #@
    #} Â¨ h

    #{
      #â€¢Show "--h"
      #sâ† { /tp=âŠ‘ğ•©âŠtp }Â¨k
        ###â€¢Show râ†ğ•©â·/tp=ğ•©âŠ‘tp
        ##â€¢Show râ†(ğ•¨â·s)
        ##â€¢Show câ†©âˆ¾(cÂ¨âŒ¾(râŠ¸/) s)âˆ¾âŸ¨âŸ¨âŸ©âŸ©
      #â€¢Show s
      #â€¢Show kâ†©âˆ¾Â¨ğ•©âŠ”s


    #}Â¨h


    #rpâ†tp
    
    #{
      #â€¢Show "---"
      #â€¢Show ğ•©â€¿ğ•¨
      #â€¢Show k
      #â€¢Show ((âˆŠğ•©)/ğ•¨)
      #kâ†©{ 
        #pâ†âŠ‘ğ•©âŠtp 
        #sâ†/(p=tp) # siblings
        #ğ•©
        #s
      #}Â¨ğ•©âŠ”k

      #â€¢Show k

      #(âˆŠğ•©)/ğ•¨
    #}Â´ âŒ½<Ë˜gm
    #k {
      #â€¢Show "---"
      ##â€¢Show sâ†/(rpâˆŠğ•©âŠrp) # siblings
      #â€¢Show ğ•¨
      #â€¢Show ğ•©
      #â€¢Show (â‰ ğ•©)â€¿(â‰ ğ•¨)
      #gâ†ğ•¨âŠ”ğ•©
      #â€¢Show { 
        #pâ†âŠ‘ğ•©âŠtp 
        #â€¢Show sâ†/(p=tp) # siblings

        #s
      #}Â¨g
    #}Â´ âŒ½<Ë˜gm

    #gmâ†âŠË˜â‰km #group matrix
      #â€¢Show "+++"
      #â€¢Show gm
    #k {
      #â€¢Show "---"
      #â€¢Show ğ•¨â€¿ğ•©
      ##â€¢Show sâ†/(rpâˆŠğ•©âŠrp) # siblings
      ##â€¢Show ğ•©âŠrp

      ###â€¢Show râ†pp=/pi # replace index. the previous parent where we want to inject our previous values
      ##â€¢Show ğ•¨âŠ”s
      ##s
    #}Â´âŒ½<Ë˜gm
    #v {
      #â€¢Show ğ•©
      #â€¢Show ğ•¨
      ##â€¢Show pâ†kâŠtp
      ##â€¢Show ğ•©âŠ”k
      #ğ•¨
    #} gm
    #{
      #â€¢Show sâ†(tp=ğ•©âŠ‘tp) # siblings
      #â€¢Show /s
      ##â€¢Show âˆ¾ğ•©Â¨âŒ¾((ğ•©=/s)âŠ¸/) /s

    #}Â¨k
    
    #â€¢ShowÂ¨(âŠ1âŠË˜km)âŠ”k
    #â€¢ShowÂ¨(âŠ2âŠË˜km)âŠ”k
    #pâ†{ pâ†âŸ¨âŸ© â‹„ { xâ†âŠ‘ğ•©âŠtp â‹„ pâ†©pâˆ¾x â‹„ x } _fix ğ•© â‹„ pâ†©Â¯1â†“p }Â¨g
    #â€¢Show gâ†(+`(Â»â‰ âŸœÂ«k))âŠ”dmâŠËœdpâŠËœv # group of template parents of values
  }

  #{
    #â€¢Show { ğ•© }Â¨â†•d
    #â€¢Show oâ†(v/dp)âŠdp   # o->k->v objects are groups
    #â€¢Show oâŠdpâŠdp   # o->k->v objects are groups


    #{
      #oâ†(v/dp)âŠdp   # o->k->v objects are groups
      #gâ†(+`(Â»â‰ âŸœÂ«o))âŠ”dmâŠËœdpâŠËœ/v # group of template parents of values
    #}

    #â€¢Show âŸ¨âŸ¨âŸ¨7,5âŸ©,âŸ¨7,5âŸ©âŸ©,âŸ¨âŸ¨7,5âŸ©,âŸ¨7,5âŸ©,âŸ¨7,5âŸ©âŸ©âŸ©
    #â€¢Show tnâ†©tnâˆ¾(v/dr)âŠdn
    #â€¢Show (pâŠtr)âŠtn
    #template children with parent p
    #v0â†â‹ˆÂ¨iâŠ”p

    # setup initial with siblings
    #v0â†{ 
      #pâ† âŠ‘ğ•©âŠtp
      #pâ€¿(
    #}Â¨iâŠ”p

      #â€¢Show "=="
      #â€¢Show "=="
      #â€¢Show "=="
    #pâ†{ pâ†âŸ¨âŸ© â‹„ { xâ†âŠ‘ğ•©âŠtp â‹„ pâ†©pâˆ¾x â‹„ x } _fix ğ•© â‹„ pâ†©Â¯1â†“p }Â¨g
    #câ†(p) { 
      #câ†/tp=âŠ‘ğ•¨
      #â€¢Show {
      #â€¢Show "--"
        #â€¢Show ğ•¨â€¿ğ•©
        #â€¢Show c
        #â€¢Show sâ†/tp=ğ•©
        ##â€¢Show râ†ğ•©â·/tp=ğ•©âŠ‘tp
        #â€¢Show râ†(ğ•¨â·s)
        #â€¢Show câ†©âˆ¾(cÂ¨âŒ¾(râŠ¸/) s)âˆ¾âŸ¨âŸ¨âŸ©âŸ©

        ## replace index. the previous parent where we want to inject our previous values
      #}Â´ğ•¨
      #c
    #} Â¨(g)

    #â€¢Show c
    #â€¢Show ((âˆ¾c)âŠtr)âŠtn
    #pâ†{âŠ‘ğ•©âŠtp}Â¨g
    #qâ†{/tpâˆŠğ•©âŠtp}Â¨g

    ##â€¢Show p {
      ##â€¢Show ğ•¨â€¿ğ•©
      ##sâ†(tp=ğ•¨âŠ‘tp) # siblings (ie nodes with shared)
      ##â€¢Show râ†ğ•¨=/s # replace index. the previous parent where we want to inject our previous values
      ##â€¢Show pâ†âŠ‘pi/tp

    ##}Â¨ q


    #qâ†©p { 
      #tp=ğ•¨âŠ‘tp
      #sâ†(tp=ğ•¨âŠ‘tp) â‹„ âˆ¾ğ•©Â¨âŒ¾((ğ•¨=/s)âŠ¸/) /s 
    #}Â¨q
    #pâ†©{âŠ‘(tp=ğ•©âŠ‘tp)/tp}Â¨p # siblings (ie nodes with shared)

    ##â€¢Show p
    ##â€¢Show q

    #qâ†©p{
      #â€¢Show ğ•¨
      #â€¢Show tp=ğ•¨âŠ‘tp

      #sâ†(tp=ğ•¨âŠ‘tp) â‹„ 

      #â€¢Show ğ•¨=/s
      #âˆ¾ğ•©Â¨âŒ¾((ğ•¨=/s)âŠ¸/) /s
    #}Â¨ q
    #pâ†©{
      #âŠ‘(tp=ğ•©âŠ‘tp)/tp
    #}Â¨p # siblings (ie nodes with shared)

    #â€¢Show p
    #â€¢Show q

    #â€¢Show v0

    #v1 â† {
      #ppâ€¿x â†ğ•©
      #â€¢Show piâ†(tp=ppâŠ‘tp) # siblings (ie nodes with shared)
      #â€¢Show râ†pp=/pi # replace index. the previous parent where we want to inject our previous values
      #â€¢Show pâ† âŠ‘pi/tp

      #pâ€¿(âˆ¾xÂ¨âŒ¾(râŠ¸/) /pi)
    #} Â¨v0

    #v2 â† {
      #ppâ€¿x â†ğ•©
      #â€¢Show piâ†(tp=ppâŠ‘tp) # siblings (ie nodes with shared)
      #â€¢Show râ†pp=/pi # replace index. the previous parent where we want to inject our previous values
      #â€¢Show pâ† âŠ‘pi/tp

      #pâ€¿(âˆ¾xÂ¨âŒ¾(râŠ¸/) /pi)
    #} Â¨v1

    #â€¢Show v1
    #â€¢Show v2


    #v1â†{
      #pâ†ğ•©âŠtpâŠtp
      #â€¢Show ğ•©âŠtp
      #â€¢Show (/tpâˆŠp)

      #râ†pâˆŠğ•©
      ##â€¢Show pâˆŠğ•©
      ##â€¢Show p
      ##â€¢Show ğ•©
      ##âˆ¾ğ•©Â¨âŒ¾(râŠ¸/) p
    #}Â¨v0

    #â€¢Show v1

    #v2â†{
      #pâ†/tpâˆŠğ•©âŠtpâŠtp
      #râ†p=âŠ‘ğ•©âŠtp
      #âˆ¾ğ•©Â¨âŒ¾(râŠ¸/) p
    #}Â¨v1

    #â€¢Show v2


    # apply roots
    #v2â†{
      #â€¢Show "--"
      #â€¢Show ğ•©
      #â€¢Show ğ•©âŠtp
      #pâ†/tpâˆŠğ•©âŠtpâŠtp
      #râ†p=âŠ‘ğ•©âŠtp
      #âˆ¾ğ•©Â¨âŒ¾(râŠ¸/) p
    #}Â¨v1

    #â€¢Show v0
    #â€¢Show v1
    #â€¢Show v2
    #v3â†{
      #â€¢Show ((âŠ‘ğ•©âŠtp)âŠtr)âŠtn
      #â€¢Show pâ†/tpâˆŠğ•©âŠtp
      #râ†p=âŠ‘ğ•©âŠtp
      #âˆ¾ğ•©Â¨âŒ¾(râŠ¸/) p
    #}Â¨v2

    #v4â†{
      #pâ† /tpâˆŠğ•©âŠtpâŠtp
      #râ†p=âŠ‘ğ•©âŠtp
      #âˆ¾ğ•©Â¨âŒ¾(râŠ¸/) p
    #}Â¨v3

    #v5â†{
      #pâ† /tpâˆŠğ•©âŠtpâŠtp
      #râ†p=âŠ‘ğ•©âŠtp
      #âˆ¾ğ•©Â¨âŒ¾(râŠ¸/) p
    #}Â¨v4

    #iiâ†(âˆ¾v1)
    #zzâ†(iiâˆŠp)
    #ttrâ†iiâŠtr
    #nâ†(v/dr)âŠdn
    #ttnâ†tnâˆ¾n

    #ttrâ†©((â‰ tr)+â†•â‰ n)âŒ¾(zzâŠ¸/) ttr
    #â€¢Show ttrâŠttn

    #mâ†tpâˆŠpâŠtp #template children with parent p
    #â€¢Show +`(1Â»â‰ âŸœÂ«m) # group indices
    #â€¢Show m
    #â€¢Show aâ†/v
    #{
      #aâ†©aâˆ¾Ë˜ğ•©
      #ğ•©âŠdp
    #} _fix a

    #aâ†©âŒ½1â†“â‰a
    #râ†aâŠdm
    #â€¢Show râ†©(âˆ¨Â´Ë˜râ‰ Â¯1)/r
    #{
      #â€¢Show â‰ğ•©âŠâ‰r
    #}Â¨ iâŠ”â†•â‰ i
    #get siblings
    #â€¢Show pâ†dmâŠËœdpâŠËœ/v # template parents of values
  #}
  
  #{
    #vâ†dt='v'
    #pâ†dmâŠËœdpâŠËœ/v # template parents of values
    #oâ†(v/dp)âŠdp   # o->k->v objects are groups
    #iâ†+`(Â»â‰ âŸœÂ«o) # group indices
    #gâ†iâŠ”p

    #rpâ†tp
    #rnâ†tn
    #rrâ†tr
    #â€¢Show "--====="
    #{
      #accâ†âŸ¨âŸ©
      #{
        #â€¢Show "--"
        ## left and right and
        #â€¢Show mâ†/tpâˆŠğ•©
        #acc


        ##â€¢Show iâ†+`(1Â»â‰ âŸœÂ«m) # group indices

        ##â€¢Show râ†(â‰ tp)â†‘/â¼ğ•© # repeat variables
        ##x â† âˆ¾{ âˆ¾âŸ¨ğ•©âŸ©/Ëœ1âŒˆâŒˆÂ´ğ•©âŠr }Â¨iâŠ”â†•â‰ tp # repeat pattern

        ##â€¢Show xâŠtp
        ##â€¢Show xâŠtr
        ##â€¢Show x
        ##â€¢Show r
        ##â€¢Show tp
        ##â€¢Show xâŠtp
        ##â€¢Show ğ•©
        #ğ•©âŠtp
      #} _Fix ğ•©
    #}Â¨1â†‘g
  #}

  #{ğ•Š:
    ## group by data depth
    #vâ†dt='v'
    #nâ†(v/dr)âŠdn
    #pâ†dmâŠËœdpâŠËœ/v # template parents of values
    


    #{
      #â€¢Show "--"
      #â€¢Show ğ•©
      #â€¢Show mâ†tpâˆŠğ•©âŠtp #template children with parent p
      #â€¢Show iâ†+`(1Â»â‰ âŸœÂ«m) # group indices
      #â€¢Show râ†(â‰ tp)â†‘/â¼ğ•© # repeat variables
      #â€¢Show x â† âˆ¾{ âˆ¾âŸ¨ğ•©âŸ©/Ëœ1âŒˆâŒˆÂ´ğ•©âŠr }Â¨iâŠ”â†•â‰ tp # repeat pattern

      #pâŠtp
    #} _Fix p


    #mâ†tpâˆŠpâŠtp #template children with parent p
    #iâ†+`(1Â»â‰ âŸœÂ«m) # group indices
    #r â† (â‰ tp)â†‘/â¼p # repeat variables
    #x â† âˆ¾{ âˆ¾âŸ¨ğ•©âŸ©/Ëœ1âŒˆâŒˆÂ´ğ•©âŠr }Â¨iâŠ”â†•â‰ tp # repeat pattern

    ## go through parent tree and append siblings

    ##â€¢Show (â†•â‰ tp)â‰tp
    ##â€¢Show (â†•â‰ tp)âŠtn
    ##â€¢Show (tpâˆŠ((((â†•â‰ tp)âŠtp)âŠtp)))

    ##ttrâ†xâŠtr
    ##trâ†©((â‰ tr)+â†•â‰ n)âŒ¾((ttrâˆŠp)âŠ¸/) ttr
    ##tpâ†©xâŠtp
    ##tnâ†©tnâˆ¾n

    ##â€¢Show tp
    ###â€¢Show tpâ‰tr
    ##â€¢Show trâŠtn
    ##â€¢Show tpâŠtp


    ##â€¢Show {{(âŒˆÂ´ğ•©)Â¨ğ•©}Â¨ğ•©}âŒ¾(iâŠ¸âŠ”) (â‰ tp)â†‘/â¼p

    ##â€¢Show iâŠ”â†•â‰ tp
    ##â€¢Show 1Â¨âŒ¾(mâŠ¸/) â†•â‰ tp
    ##â€¢Show 1Â¨âŒ¾(mâŠ¸/) â†•â‰ tp
    ##â€¢Show {

      ##â€¢Show ğ•©âŠr
      ##â€¢Show ğ•©
      ##ğ•©
    ##}âŒ¾(mâŠ¸/) â†•â‰ tp
    ##â€¢Show {sâ†âŒˆÂ´ğ•© â‹„ sÂ¨ğ•©}Â¨iâŠ”q

    

    ##â€¢Show m
    ##â€¢Show zâ†âŒˆ`(Â»<âŸœÂ«m)Ã—â†•â‰ tp
    ##â€¢Show (0<q)
    ##â€¢Show (0<q)Ã—+`1Â»â‰ âŸœÂ«m
    ##â€¢Show (/m)â‹(/0<q)
    ## get siblings
    

    ##â€¢Show (âŠ’p)/tp
    ##â€¢Show tpâ†©(âŠ’p)/tp
    ##â€¢Show (m/tr)âŠtn
    ##â€¢Show âŒ¾(pâŠ¸/) â†•â‰ tp
    ##â€¢Show kâ†mâˆ§tt='k' # template key children 
    ##â€¢Show mâ†tpâˆŠpâŠtp # template children with ğ•© as parent


    ##{
      ##â€¢Show vâŠdn
      ##â€¢Show mâ†tpâˆŠğ•© # template children with ğ•© as parent
      ##â€¢Show kâ†mâˆ§tt='k' # template key children 
      ###â€¢Show qâ†(1-Ëœ+`0=(â‰ k)|â†•â‰ ğ•©) # group indices

      ###â€¢Show ğ•¨â€¿ğ•©â€¿(ğ•¨â‰ ğ•©)
      ###TODO only update items that have changed
      ##pâŠtp
    ##} _Fix p

    ##â€¢Show (pâŠtr)âŠtn
    ##â€¢Show (pâŠtpâŠtr)âŠtn
    ##â€¢Show (pâŠtpâŠtpâŠtr)âŠtn
  #}

  #{
    #kâ†/dt='k'
    #vâ†/dt='v'
    #â€¢Show pâ†vâŠdp
    #â€¢Show ((/tt='k')âŠtr)âŠtn
    #â€¢Show dm
    #â€¢Show tn
    #â€¢Show 
    #â€¢Show ((((kâˆŠp)/dm)âŠ(/tt='k'))âŠtr)âŠtn
    ## set values

    ##â€¢Show dt='k'
    ##â€¢Show k
    ##â€¢Show dm
    ##â€¢Show kâˆŠtm
    ##â€¢Show (kâŠdr)âŠdn
    ##â€¢Show ((/tt='k')âŠtk)âŠkn

    ##â€¢Show (((Â¬kâˆŠtm)/k)âŠdr)âŠdn
    ## get siblings
    
  #}

  #Draw dp 
  #Draw tp



    #zâ†((â‰ kn)=m)âŒ¾((dt='k')âŠ¸/) (â‰ dt)â¥Š0 â‹„ 


    #â€¢Show ((/dt='k')âŠdr)âŠdn

    #â€¢Show k

    #â€¢Show tm
    #â€¢Show dm

    #â€¢Show Â¬kâˆŠtm
    #â€¢Show (((Â¬kâˆŠtm)/k)âŠdr)âŠdn

    #vâ†/dt='v'
    #pâ†vâŠdp
    #mâ†(/k)âˆŠtm
  #{
    #â€¢Show (/kâˆŠp)âˆŠ # get parents in key index space
    #â€¢Show (((/kâˆŠp)âŠtm)âŠtr)
    #â€¢Show ((/kâˆŠp)âŠdk)âŠkn
    #â€¢Show (/kâˆŠp)âŠdm
  #}

  # fill all value level data
  #{
    #dâ† Depth tp â‹„ tkiâ†1-Ëœ+`tkâ†tt='k'

    #{ 
      #mâ†d=ğ•©âˆ§tk
      #â€¢Show m
      #â€¢Show pâ†(/m)âŠtp
      #â€¢Show qâ†(1-Ëœm/+`>âŸœÂ»m)
      
      #â€¢Show iâ†(dt='v')âˆ§dpâˆŠ(dmâˆŠ/m)//dt='k' # data value indices of mapped template keys at current depth
        #vâ†âŠâŸœdnâŠâŸœdr oâŠi # values

        ##iâ†/(dt='v')âˆ§dpâˆŠ(dmâˆŠk)//dt='k'# indices of values and also if its parents equal to the mapped keys 

      #@
    #}Â¨âŸ¨2âŸ©#âŒ½â†•âŒˆÂ´d+1

    #{
      #â€¢Show tk
      ##â€¢Show kâ†ğ•©âŠtk # key indices
      #â€¢Show ğ•©âˆ§
    #}Ë˜
  #}

  #{
    #dâ† Depth tp â‹„ tkâ†1-Ëœ+`tt='k'
    #{
      #mâ†d=ğ•©
      #pâ†(/m)âŠtp
      #qâ†(1-Ëœm/+`>âŸœÂ»m)
        #â€¢Show "xxx"

      #(âˆ¾â·Â¨qâŠ”p) {
        #mâ†'k'=ğ•©âŠtt # key mask
        #kâ†(m/ğ•©)âŠtk # key indices
        #â€¢Show m
        ##sâ† âŠâŸœtn ğ•©âŠtr # strings
        #â€¢Show "--"

        #â€¢Show iâ†/(dt='v')âˆ§dpâˆŠ(dmâˆŠk)//dt='k'# indices of values and also if its parents equal to the mapped keys (from data mapping key table)
        #â€¢Show qâ†(1-Ëœ+`0=(â‰ k)|â†•â‰ i) # group indices
        #â€¢Show kâŠ(dmâˆŠk)/dm
        #â€¢Show q
        #oâ†(qÃ—â‰ k)+kâŠ(dmâˆŠk)/dm # index order mapping with offset depending on group
        #vâ†âŠâŸœdnâŠâŸœdr oâŠi # values

        ## add values to tree

        ##n â† âˆ¾{(ğ•©)âŒ¾(mâŠ¸/) s} Â¨qâŠ”v
        
        ##rrâ†© (â‰ rn)Â¨âŒ¾(ğ•¨âŠ¸âŠ) rr
        ##rnâ†©rn âˆ¾ âŸ¨nâŸ©
      #}Â¨qâŠ”(/m)

      ## set all used data types to value
      ##{
        ##mâ†'k'=ğ•©âŠtt # key mask
        ##kâ†(m/ğ•©)âŠtk # key indices
        ##iâ†/(dt='v')âˆ§dpâˆŠ(dmâˆŠk)//dt='k'# indices of values and also if its parents equal to the mapped keys 
        ##dtâ†© 'v'Â¨âŒ¾(iâŠ¸âŠ) dt
      ##}Â¨qâŠ”(/m)
    #}Â¨âŸ¨2,1âŸ©

  #}
    #}Â¨âŒ½â†•âŒˆÂ´d+1 # depth level matrix 


    #mâ†d=âŒˆÂ´d # lowest depth
    #tkâ†tt='k'
    #â€¢Show tlâ†(1-Ëœ+`tk)/Ëœmâˆ§tk # indices of template keys in key array (ie. array if there were only keys) that are lowest

    ## separate out parents

    ## template parents mapped to children data of matching data parents 
    #â€¢Show nâ†(â‰ tl)
    #â€¢Show iâ†dm/ËœdmâˆŠtl
    #â€¢Show gâ†tlâŠ¸âŠÂ¨(1-Ëœ+`0=n|â†•â‰ i)âŠ”i # group as set indices in v
    #â€¢SHow vâ†âŠâŸœdnâŠâŸœdr/((dt='v')âˆ§dpâˆŠ(dmâˆŠtl)//dt='k')

    #â€¢Show pi â†(1-Ëœm/+`>âŸœÂ»m) # parent group indices
    ##â€¢Show m
    ##â€¢Show (tkâˆ§m)/tkÃ—(0-Ëœ+`m)
    ##â€¢Show tk
    ##â€¢Show zâ†(tkâˆ§m)/tkÃ—(0-Ëœ+`m)
    #â€¢Show sâ†âŠâŸœtnÂ¨piâŠ”(/m)âŠtr

    ## grouped values
    #â€¢Show vgâ†(âŠâŸœvÂ¨g+Â¨nÃ—â†•â‰ g)

    #s { ğ•© }Â¨vg
    #â€¢Show /mâŠtrâŠtn
    #â€¢Show { 
      #â€¢Show z
      ##â€¢Show ğ•©âŠtn
      #â€¢Show nnâ†
      #ğ•©â€¿ğ•¨ 

    #}Â¨
    #â€¢Show nnâ†((/m)âŠtr)âŠtn
    #â€¢Show {(ğ•©)âŒ¾(zâŠ¸âŠ) nn} # access value with key offsets


    #â€¢Show (1-Ëœ+`tk)
    #â€¢Show ((/m)âŠtr)âŠtn
    #â€¢Show tl

    # 
    # mark 

    #â€¢Show (mâˆ§tk)
    #â€¢Show ((mâˆ§tk)/tr)âŠkn
    #â€¢Show ((mâˆ§Â¬tk)/tr)âŠtn
    #â€¢Show tlâŠtm # map template keys to data vales

    #rrâ†©rrâˆ¾(â‰ rr)+â†•â‰ m
    #rnâ†©rnâˆ¾(dr/Ëœdt='v')âŠdn

    #â€¢Show rr
    #â€¢Show rn

    #dt â†© 'v'Â¨âŒ¾(mâŠ¸âŠ) dt 

  #}
  #
}


Compile0 â‡ {
   ğ•¨ ğ•Š ğ•© : (Â¬ğ•© â€¢ns.Has "ptr") ? ğ•¨ ğ•Š (ParseNs ğ•©);
   ğ•¨ ğ•Š ğ•© : 
    âŸ¨[tp,tt,tr]â‡ptr,tnâ‡nâŸ©â†ğ•¨ â‹„ âŸ¨[dp,dt,dr]â‡ptr,dnâ‡nâŸ©â†ğ•©

    #data key parent vector. dki -> original indices
    dkp â† @ â‹„ dkr â† @ â‹„ dki â† @ 
    #template key parent vector
    tkp â† @ â‹„ tkr â† @ â‹„ tki â† @


     # create data parent vector of only keys
     {
      mâ†(dt='k')âˆ§(dp=0)
      dkpâ†©(/m)âŒ¾(mâŠ¸/) dp # set roots of keys
      dkpâ†©{ğ•©âŠdkp}âŒ¾((dt='k')âŠ¸/) dkp # remap key parents to keys
      dkpâ†©((dt='o') âˆ¨ (dt='v')) Delete dkp #delete objs and values

      dkrâ†©(dt='k')/dr
      dkiâ†©(dt='k')/â†•â‰ dt
     }

     # create template parent vector of only keys
    tkp â†© (ttâ‰ 'k') Delete tp
    tkr â†© (tt='k') / tr
    tki â†© (tt='k') / â†•â‰ tr

    # set data key indices to match template indices and remove any non existing keys
    {
      # find names that don't exist in template variables
      eâ†(tkrâŠtn)âŠ(dkrâŠdn)
      # z mask to remove all non existing data names and delete all children with deleted parents
      zâ†(â‰ tkr)=e â‹„ { zâ†©zâˆ¨(ğ•©âŠz) â‹„ ğ•©âŠdkp} _fix dkp
      # map references to names that do exist to matching template references
      mâ†âŠâŸœtkrâŒ¾(((â‰ tkr)â‰ e)âŠ¸/) e
      # delete all references that do not have a name variable in template
      # delete all children of parents of non existing vars
      dkpâ†©z Delete dkp
      dkrâ†©(Â¬z)/m
      dkiâ†©(Â¬z)/dki
    }

    # extract valid paths
    {
      PathMat â†{
        dâ†Depth ğ•©
        dmâ†d=âŒœËœâ†•âŒˆÂ´d+1 
        dmâ†© âŒˆ`Ë˜â‰+`Ë˜â‰(â†•â‰ ğ•¨)âŠ¸Ã—Ë˜dm
        âŠâŸœğ•¨Ë˜dm
      }
      â€¢Show dpm â† dkr PathMat dkp
      â€¢Show tpm â† tkr PathMat tkp
      â€¢Show dpmatch â† (<Ë˜â‰tpm)âŠ(<Ë˜â‰dpm)
      â€¢Show tpmatch â† (<Ë˜â‰dpm)âŠ(<Ë˜â‰tpm)
      

      # for each data at lowest find matching template

      tdâ†Depth tp
      ddâ†Depth dp


      #{
        #â€¢Show ğ•©
        ##kâ†dt='k'
        #mâ†dd=ğ•©âˆ¨(dt='v')
        #zâ†m

        ##parent of children k->v -> then rematch as v
        #â€¢Show ppâ†âŠ‘âŸœdpÂ¨/z
        ###â€¢Show (âŠ‘âŸœdpÂ¨/z)âŠdt

        ##(ppâŠdr)âŠdn

        ### map to key index
        ##â€¢Show pp
        ##â€¢Show dki
        ### match to template depth path matrix index
        #â€¢Show ppâŠdpmatch
        ##â€¢Show dpmatch
        #zzâ†ppâŠdpmatch

        ## get surrounding sibling fragments ie same parents
        ##â€¢Show zz
        ##â€¢Show /â¼zz
        #â€¢Show qqâ†âˆ¨Â´{ ğ•©=tp }Â¨zzâŠtkpâŠtki
        ##â€¢Show zzâŠtki

        #â€¢Show fgâ† ((/qq)âŠtr)âŠtn # fragments
        #â€¢Show kâ† (zzâŠtkr)âŠtn
        #â€¢Show vâ† (z/dr)âŠdn # values

        ##â€¢Show kâŠfg
        ##â€¢Show mm â† fgâˆŠk
        ##â€¢Show inâ†(mm/kâŠfg)âŠ¸âŠ v
        ##â€¢Show inâŒ¾(mmâŠ¸/) fg

        ### apply 

        #â€¢Show cnâ† (zzâŠtkr)âŠtn
        #â€¢Show crâ† â†•â‰ cn
        #â€¢Show cpâ† â†•â‰ cn

        ##cpâ€¿crâ€¿cn
      #}Â¨ âŸ¨âŒˆÂ´tdâŸ©

    }


    #{ ğ•Š:

      #â€¢Show tpm
      #â€¢Show tpmatch

      #â€¢Show dpm
      #â€¢Show dpmatch

      #â€¢Show kâ†tt='k'
      #â€¢Show mâ†d=âŒˆÂ´d
      #â€¢Show zâ†(mâˆ§k)
      #r â†tr(âŠ¢/Ã—)z # references for current depth
      
      #â€¢Show tnâŠËœtr(âŠ¢/Ã—)z
      #â€¢Show /(zÃ—tr)/tn

      #â€¢Show dâ‰tkp
      ## while


      # get children of depth x
        # get parent
          # separate to parent
            # parent key is now children rendered
          

      #â€¢Show (mâˆ§k)Ã—tpâŠtp
      # replace 
      #â€¢Show âŒ¾((0>z)âŠ¸/) z
    #}




    #{
      #dâ†Depth dkp
      #dmâ†d=âŒœËœâ†•âŒˆÂ´d+1 
      #â€¢Show dkr
      #â€¢Show dm
      #â€¢Show â‰+`Ë˜â‰dm
      ##â€¢Show {  âŠâŒ¾(ğ•©âŠ¸/) dkr}Ë˜dm
    #}

    #{
      #dâ†Depth tkp
      #â€¢Show tkr
      #dmâ†d=âŒœËœâ†•âŒˆÂ´d+1 
      #â€¢Show dm
      ##â€¢Show {(â‰ d)â†‘ğ•©/tkr}Ë˜dm
    #}
    #(0âŠ¸âŠÂ¨tkr) Draw tkp
    #({0âŠ‘ğ•©âŠ‘tn}Â¨tkr)  Draw tkp

       
    #(0âŠ¸âŠ‘Â¨(dt='k')âŠdn)Draw dkp

    #â€¢Show tkr âŠ tn
    #Draw tkp
    #tt Draw tp
    #â€¢Show mâ†dt='k'
    #â€¢Show mâ†dt='v'
    #â€¢Show m/dt
    #(m/dt) Draw m Delete dpâŠdp

    #{ dâ† Depth dp â‹„ â€¢Show d=âŒœËœâ†•âŒˆÂ´d+1 }
    #{ dâ† Depth tp â‹„ â€¢Show d=âŒœËœâ†•âŒˆÂ´d+1 }

    #â€¢Show (((dt='k')/dr)âŠdn)
    #â€¢Show (((tt='k')/tr)âŠtn)
    #â€¢Show (((dt='k')/dr)âŠdn)âˆŠ((tt='k')/tr)âŠtn

    #{
      #mâ† dt='k'

      #dt Draw dp
      #(m/dt) Draw m/dpâŠdp
    #}
    #tdâ† Depth tp
    #â€¢Show tr

    #dv â† ((dt='k')/dr)âŠdn
    #tvâ† (((tt='v')âˆ¨(tt='o'))/tr)âŠtn # variable names

    #dt Draw dp
    ## TODO check existence by depth
    #â€¢Show dvâ€¿tv
    #â€¢Show dvâˆŠtv
    # create key tree
    #dt Draw dp
}



#Compile0 â† {
  ## ip: replace parent, rv: replace values, r: references, t: types, p: parent, ch: characters, n: names
  #ipâ€¿rv â† ğ•¨ â‹„ rn â† (â‰ ip)â¥ŠÂ¯1 â‹„ ch â† â€¢file.Chars ğ•© â‹„ r â† (â‰ ch)â¥ŠÂ¯1 â‹„ t â† p â† (â‰ ch)â¥Š0 â‹„ n â† @

  #Print â† { ğ•Š: â€¢Show [ip, rv, rn] â‹„ â€¢Show [p, t, r] â‹„ â€¢Show n }

  #oâ€¿c â† {âˆ¨âŸœÂ»âŸ(1-Ëœâ‰ ğ•©)(â‰ ch)â†‘ğ•©â·ch}Â¨opnâ€¿cls               # get open and close enclose bits
  #t â†© +`(Â»>âŸœÂ«o)+-(Â»âŠ¸<c)                               # pass: mark names in types
  #d â† (Â¬oâˆ¨c) â‹„ ch dâŠ¸/ â†© â‹„ p dâŠ¸/ â†© â‹„ t dâŠ¸/ â†© â‹„ r dâŠ¸/ â†© # pass: remove brackets

  ## pass: names to '$' tags with types and references to original names
  #{
    #i â† (0âŠ¸â‰ â‰ Â¨)âŠ¸/âŠ”(âŠ¢-ËœÂ¬Ã—+`)Â¬t=types.b

    #nm â† (Â¬âˆŠâŸœ"#/")âŠ¸/Â¨ âŠâŸœchÂ¨i # names: extracted tag strings
    #b â† (â‰ ch)â†‘(/â¼0âŠ‘Â¨i) # base tags - opn of tags
    #s â† types.sÃ—bâˆ§ch='#' # opn tags
    #e â† types.eÃ—bâˆ§ch='/' # cls tags
    #d â† (t=types.b)Ã—Â¬b

    #rn â†© Â¯1Â¨âŒ¾(((â‰ nm)=nmâŠrv)âŠ¸/) nmâŠrv
    #n  â†© (â‰âŸœâŠ) nm
    #r  â†© (Â¬d)/(âŠnm)âŒ¾(bâŠ¸/) r
    #p  â†© d Delete p
    #t  â†© (Â¬d)/âŒˆÂ´bâ€¿sâ€¿e
    #ch â†© (Â¬d)/'$'Â¨âŒ¾(bâŠ¸/) ch
  #}


  #p â†© +`(Â»>âŸœÂ«(t=types.s))+-(Â»âŠ¸<(t=types.e))           # pass: construct parents from opn/cls tags

  #Print @
#}
